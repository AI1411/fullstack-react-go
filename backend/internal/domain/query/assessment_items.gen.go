// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/AI1411/fullstack-react-go/internal/domain/model"
)

func newAssessmentItem(db *gorm.DB, opts ...gen.DOOption) assessmentItem {
	_assessmentItem := assessmentItem{}

	_assessmentItem.assessmentItemDo.UseDB(db, opts...)
	_assessmentItem.assessmentItemDo.UseModel(&model.AssessmentItem{})

	tableName := _assessmentItem.assessmentItemDo.TableName()
	_assessmentItem.ALL = field.NewAsterisk(tableName)
	_assessmentItem.ID = field.NewInt32(tableName, "id")
	_assessmentItem.AssessmentID = field.NewInt32(tableName, "assessment_id")
	_assessmentItem.ItemName = field.NewString(tableName, "item_name")
	_assessmentItem.FacilityTypeID = field.NewInt32(tableName, "facility_type_id")
	_assessmentItem.DamageLevelID = field.NewInt32(tableName, "damage_level_id")
	_assessmentItem.DamageDescription = field.NewString(tableName, "damage_description")
	_assessmentItem.DamageAmount = field.NewFloat64(tableName, "damage_amount")
	_assessmentItem.ApprovedAmount = field.NewFloat64(tableName, "approved_amount")
	_assessmentItem.LocationLatitude = field.NewFloat64(tableName, "location_latitude")
	_assessmentItem.LocationLongitude = field.NewFloat64(tableName, "location_longitude")
	_assessmentItem.Notes = field.NewString(tableName, "notes")
	_assessmentItem.CreatedAt = field.NewTime(tableName, "created_at")
	_assessmentItem.UpdatedAt = field.NewTime(tableName, "updated_at")
	_assessmentItem.DeletedAt = field.NewField(tableName, "deleted_at")

	_assessmentItem.fillFieldMap()

	return _assessmentItem
}

type assessmentItem struct {
	assessmentItemDo

	ALL               field.Asterisk
	ID                field.Int32   // 査定項目ID - 主キー
	AssessmentID      field.Int32   // 査定ID - 関連する査定のID
	ItemName          field.String  // 項目名 - 査定項目の名称
	FacilityTypeID    field.Int32   // 施設種別ID - 被害を受けた施設の種別
	DamageLevelID     field.Int32   // 被害程度ID - 被害の程度
	DamageDescription field.String  // 被害説明 - 被害状況の詳細説明
	DamageAmount      field.Float64 // 被害金額 - 項目ごとの被害金額
	ApprovedAmount    field.Float64 // 承認金額 - 項目ごとの承認金額
	LocationLatitude  field.Float64 // 位置（緯度） - 被害箇所の緯度
	LocationLongitude field.Float64 // 位置（経度） - 被害箇所の経度
	Notes             field.String  // 備考 - 査定項目に関する備考やメモ
	CreatedAt         field.Time    // 作成日時 - レコード作成日時
	UpdatedAt         field.Time    // 更新日時 - レコード最終更新日時
	DeletedAt         field.Field   // 削除日時 - 論理削除用のタイムスタンプ

	fieldMap map[string]field.Expr
}

func (a assessmentItem) Table(newTableName string) *assessmentItem {
	a.assessmentItemDo.UseTable(newTableName)
	return a.updateTableName(newTableName)
}

func (a assessmentItem) As(alias string) *assessmentItem {
	a.assessmentItemDo.DO = *(a.assessmentItemDo.As(alias).(*gen.DO))
	return a.updateTableName(alias)
}

func (a *assessmentItem) updateTableName(table string) *assessmentItem {
	a.ALL = field.NewAsterisk(table)
	a.ID = field.NewInt32(table, "id")
	a.AssessmentID = field.NewInt32(table, "assessment_id")
	a.ItemName = field.NewString(table, "item_name")
	a.FacilityTypeID = field.NewInt32(table, "facility_type_id")
	a.DamageLevelID = field.NewInt32(table, "damage_level_id")
	a.DamageDescription = field.NewString(table, "damage_description")
	a.DamageAmount = field.NewFloat64(table, "damage_amount")
	a.ApprovedAmount = field.NewFloat64(table, "approved_amount")
	a.LocationLatitude = field.NewFloat64(table, "location_latitude")
	a.LocationLongitude = field.NewFloat64(table, "location_longitude")
	a.Notes = field.NewString(table, "notes")
	a.CreatedAt = field.NewTime(table, "created_at")
	a.UpdatedAt = field.NewTime(table, "updated_at")
	a.DeletedAt = field.NewField(table, "deleted_at")

	a.fillFieldMap()

	return a
}

func (a *assessmentItem) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := a.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (a *assessmentItem) fillFieldMap() {
	a.fieldMap = make(map[string]field.Expr, 14)
	a.fieldMap["id"] = a.ID
	a.fieldMap["assessment_id"] = a.AssessmentID
	a.fieldMap["item_name"] = a.ItemName
	a.fieldMap["facility_type_id"] = a.FacilityTypeID
	a.fieldMap["damage_level_id"] = a.DamageLevelID
	a.fieldMap["damage_description"] = a.DamageDescription
	a.fieldMap["damage_amount"] = a.DamageAmount
	a.fieldMap["approved_amount"] = a.ApprovedAmount
	a.fieldMap["location_latitude"] = a.LocationLatitude
	a.fieldMap["location_longitude"] = a.LocationLongitude
	a.fieldMap["notes"] = a.Notes
	a.fieldMap["created_at"] = a.CreatedAt
	a.fieldMap["updated_at"] = a.UpdatedAt
	a.fieldMap["deleted_at"] = a.DeletedAt
}

func (a assessmentItem) clone(db *gorm.DB) assessmentItem {
	a.assessmentItemDo.ReplaceConnPool(db.Statement.ConnPool)
	return a
}

func (a assessmentItem) replaceDB(db *gorm.DB) assessmentItem {
	a.assessmentItemDo.ReplaceDB(db)
	return a
}

type assessmentItemDo struct{ gen.DO }

type IAssessmentItemDo interface {
	gen.SubQuery
	Debug() IAssessmentItemDo
	WithContext(ctx context.Context) IAssessmentItemDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IAssessmentItemDo
	WriteDB() IAssessmentItemDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IAssessmentItemDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IAssessmentItemDo
	Not(conds ...gen.Condition) IAssessmentItemDo
	Or(conds ...gen.Condition) IAssessmentItemDo
	Select(conds ...field.Expr) IAssessmentItemDo
	Where(conds ...gen.Condition) IAssessmentItemDo
	Order(conds ...field.Expr) IAssessmentItemDo
	Distinct(cols ...field.Expr) IAssessmentItemDo
	Omit(cols ...field.Expr) IAssessmentItemDo
	Join(table schema.Tabler, on ...field.Expr) IAssessmentItemDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IAssessmentItemDo
	RightJoin(table schema.Tabler, on ...field.Expr) IAssessmentItemDo
	Group(cols ...field.Expr) IAssessmentItemDo
	Having(conds ...gen.Condition) IAssessmentItemDo
	Limit(limit int) IAssessmentItemDo
	Offset(offset int) IAssessmentItemDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IAssessmentItemDo
	Unscoped() IAssessmentItemDo
	Create(values ...*model.AssessmentItem) error
	CreateInBatches(values []*model.AssessmentItem, batchSize int) error
	Save(values ...*model.AssessmentItem) error
	First() (*model.AssessmentItem, error)
	Take() (*model.AssessmentItem, error)
	Last() (*model.AssessmentItem, error)
	Find() ([]*model.AssessmentItem, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.AssessmentItem, err error)
	FindInBatches(result *[]*model.AssessmentItem, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.AssessmentItem) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IAssessmentItemDo
	Assign(attrs ...field.AssignExpr) IAssessmentItemDo
	Joins(fields ...field.RelationField) IAssessmentItemDo
	Preload(fields ...field.RelationField) IAssessmentItemDo
	FirstOrInit() (*model.AssessmentItem, error)
	FirstOrCreate() (*model.AssessmentItem, error)
	FindByPage(offset int, limit int) (result []*model.AssessmentItem, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IAssessmentItemDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (a assessmentItemDo) Debug() IAssessmentItemDo {
	return a.withDO(a.DO.Debug())
}

func (a assessmentItemDo) WithContext(ctx context.Context) IAssessmentItemDo {
	return a.withDO(a.DO.WithContext(ctx))
}

func (a assessmentItemDo) ReadDB() IAssessmentItemDo {
	return a.Clauses(dbresolver.Read)
}

func (a assessmentItemDo) WriteDB() IAssessmentItemDo {
	return a.Clauses(dbresolver.Write)
}

func (a assessmentItemDo) Session(config *gorm.Session) IAssessmentItemDo {
	return a.withDO(a.DO.Session(config))
}

func (a assessmentItemDo) Clauses(conds ...clause.Expression) IAssessmentItemDo {
	return a.withDO(a.DO.Clauses(conds...))
}

func (a assessmentItemDo) Returning(value interface{}, columns ...string) IAssessmentItemDo {
	return a.withDO(a.DO.Returning(value, columns...))
}

func (a assessmentItemDo) Not(conds ...gen.Condition) IAssessmentItemDo {
	return a.withDO(a.DO.Not(conds...))
}

func (a assessmentItemDo) Or(conds ...gen.Condition) IAssessmentItemDo {
	return a.withDO(a.DO.Or(conds...))
}

func (a assessmentItemDo) Select(conds ...field.Expr) IAssessmentItemDo {
	return a.withDO(a.DO.Select(conds...))
}

func (a assessmentItemDo) Where(conds ...gen.Condition) IAssessmentItemDo {
	return a.withDO(a.DO.Where(conds...))
}

func (a assessmentItemDo) Order(conds ...field.Expr) IAssessmentItemDo {
	return a.withDO(a.DO.Order(conds...))
}

func (a assessmentItemDo) Distinct(cols ...field.Expr) IAssessmentItemDo {
	return a.withDO(a.DO.Distinct(cols...))
}

func (a assessmentItemDo) Omit(cols ...field.Expr) IAssessmentItemDo {
	return a.withDO(a.DO.Omit(cols...))
}

func (a assessmentItemDo) Join(table schema.Tabler, on ...field.Expr) IAssessmentItemDo {
	return a.withDO(a.DO.Join(table, on...))
}

func (a assessmentItemDo) LeftJoin(table schema.Tabler, on ...field.Expr) IAssessmentItemDo {
	return a.withDO(a.DO.LeftJoin(table, on...))
}

func (a assessmentItemDo) RightJoin(table schema.Tabler, on ...field.Expr) IAssessmentItemDo {
	return a.withDO(a.DO.RightJoin(table, on...))
}

func (a assessmentItemDo) Group(cols ...field.Expr) IAssessmentItemDo {
	return a.withDO(a.DO.Group(cols...))
}

func (a assessmentItemDo) Having(conds ...gen.Condition) IAssessmentItemDo {
	return a.withDO(a.DO.Having(conds...))
}

func (a assessmentItemDo) Limit(limit int) IAssessmentItemDo {
	return a.withDO(a.DO.Limit(limit))
}

func (a assessmentItemDo) Offset(offset int) IAssessmentItemDo {
	return a.withDO(a.DO.Offset(offset))
}

func (a assessmentItemDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IAssessmentItemDo {
	return a.withDO(a.DO.Scopes(funcs...))
}

func (a assessmentItemDo) Unscoped() IAssessmentItemDo {
	return a.withDO(a.DO.Unscoped())
}

func (a assessmentItemDo) Create(values ...*model.AssessmentItem) error {
	if len(values) == 0 {
		return nil
	}
	return a.DO.Create(values)
}

func (a assessmentItemDo) CreateInBatches(values []*model.AssessmentItem, batchSize int) error {
	return a.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (a assessmentItemDo) Save(values ...*model.AssessmentItem) error {
	if len(values) == 0 {
		return nil
	}
	return a.DO.Save(values)
}

func (a assessmentItemDo) First() (*model.AssessmentItem, error) {
	if result, err := a.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.AssessmentItem), nil
	}
}

func (a assessmentItemDo) Take() (*model.AssessmentItem, error) {
	if result, err := a.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.AssessmentItem), nil
	}
}

func (a assessmentItemDo) Last() (*model.AssessmentItem, error) {
	if result, err := a.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.AssessmentItem), nil
	}
}

func (a assessmentItemDo) Find() ([]*model.AssessmentItem, error) {
	result, err := a.DO.Find()
	return result.([]*model.AssessmentItem), err
}

func (a assessmentItemDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.AssessmentItem, err error) {
	buf := make([]*model.AssessmentItem, 0, batchSize)
	err = a.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (a assessmentItemDo) FindInBatches(result *[]*model.AssessmentItem, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return a.DO.FindInBatches(result, batchSize, fc)
}

func (a assessmentItemDo) Attrs(attrs ...field.AssignExpr) IAssessmentItemDo {
	return a.withDO(a.DO.Attrs(attrs...))
}

func (a assessmentItemDo) Assign(attrs ...field.AssignExpr) IAssessmentItemDo {
	return a.withDO(a.DO.Assign(attrs...))
}

func (a assessmentItemDo) Joins(fields ...field.RelationField) IAssessmentItemDo {
	for _, _f := range fields {
		a = *a.withDO(a.DO.Joins(_f))
	}
	return &a
}

func (a assessmentItemDo) Preload(fields ...field.RelationField) IAssessmentItemDo {
	for _, _f := range fields {
		a = *a.withDO(a.DO.Preload(_f))
	}
	return &a
}

func (a assessmentItemDo) FirstOrInit() (*model.AssessmentItem, error) {
	if result, err := a.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.AssessmentItem), nil
	}
}

func (a assessmentItemDo) FirstOrCreate() (*model.AssessmentItem, error) {
	if result, err := a.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.AssessmentItem), nil
	}
}

func (a assessmentItemDo) FindByPage(offset int, limit int) (result []*model.AssessmentItem, count int64, err error) {
	result, err = a.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = a.Offset(-1).Limit(-1).Count()
	return
}

func (a assessmentItemDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = a.Count()
	if err != nil {
		return
	}

	err = a.Offset(offset).Limit(limit).Scan(result)
	return
}

func (a assessmentItemDo) Scan(result interface{}) (err error) {
	return a.DO.Scan(result)
}

func (a assessmentItemDo) Delete(models ...*model.AssessmentItem) (result gen.ResultInfo, err error) {
	return a.DO.Delete(models)
}

func (a *assessmentItemDo) withDO(do gen.Dao) *assessmentItemDo {
	a.DO = *do.(*gen.DO)
	return a
}
