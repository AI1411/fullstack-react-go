// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"database/sql"

	"gorm.io/gorm"

	"gorm.io/gen"

	"gorm.io/plugin/dbresolver"
)

var (
	Q                  = new(Query)
	Assessment         *assessment
	AssessmentComment  *assessmentComment
	AssessmentItem     *assessmentItem
	DamageLevel        *damageLevel
	Disaster           *disaster
	DisasterDocument   *disasterDocument
	EmailHistory       *emailHistory
	FacilityEquipment  *facilityEquipment
	FacilityType       *facilityType
	GisDatum           *gisDatum
	Municipality       *municipality
	Notification       *notification
	Organization       *organization
	Prefecture         *prefecture
	Role               *role
	SupportApplication *supportApplication
	Timeline           *timeline
	User               *user
	UserOrganization   *userOrganization
)

func SetDefault(db *gorm.DB, opts ...gen.DOOption) {
	*Q = *Use(db, opts...)
	Assessment = &Q.Assessment
	AssessmentComment = &Q.AssessmentComment
	AssessmentItem = &Q.AssessmentItem
	DamageLevel = &Q.DamageLevel
	Disaster = &Q.Disaster
	DisasterDocument = &Q.DisasterDocument
	EmailHistory = &Q.EmailHistory
	FacilityEquipment = &Q.FacilityEquipment
	FacilityType = &Q.FacilityType
	GisDatum = &Q.GisDatum
	Municipality = &Q.Municipality
	Notification = &Q.Notification
	Organization = &Q.Organization
	Prefecture = &Q.Prefecture
	Role = &Q.Role
	SupportApplication = &Q.SupportApplication
	Timeline = &Q.Timeline
	User = &Q.User
	UserOrganization = &Q.UserOrganization
}

func Use(db *gorm.DB, opts ...gen.DOOption) *Query {
	return &Query{
		db:                 db,
		Assessment:         newAssessment(db, opts...),
		AssessmentComment:  newAssessmentComment(db, opts...),
		AssessmentItem:     newAssessmentItem(db, opts...),
		DamageLevel:        newDamageLevel(db, opts...),
		Disaster:           newDisaster(db, opts...),
		DisasterDocument:   newDisasterDocument(db, opts...),
		EmailHistory:       newEmailHistory(db, opts...),
		FacilityEquipment:  newFacilityEquipment(db, opts...),
		FacilityType:       newFacilityType(db, opts...),
		GisDatum:           newGisDatum(db, opts...),
		Municipality:       newMunicipality(db, opts...),
		Notification:       newNotification(db, opts...),
		Organization:       newOrganization(db, opts...),
		Prefecture:         newPrefecture(db, opts...),
		Role:               newRole(db, opts...),
		SupportApplication: newSupportApplication(db, opts...),
		Timeline:           newTimeline(db, opts...),
		User:               newUser(db, opts...),
		UserOrganization:   newUserOrganization(db, opts...),
	}
}

type Query struct {
	db *gorm.DB

	Assessment         assessment
	AssessmentComment  assessmentComment
	AssessmentItem     assessmentItem
	DamageLevel        damageLevel
	Disaster           disaster
	DisasterDocument   disasterDocument
	EmailHistory       emailHistory
	FacilityEquipment  facilityEquipment
	FacilityType       facilityType
	GisDatum           gisDatum
	Municipality       municipality
	Notification       notification
	Organization       organization
	Prefecture         prefecture
	Role               role
	SupportApplication supportApplication
	Timeline           timeline
	User               user
	UserOrganization   userOrganization
}

func (q *Query) Available() bool { return q.db != nil }

func (q *Query) clone(db *gorm.DB) *Query {
	return &Query{
		db:                 db,
		Assessment:         q.Assessment.clone(db),
		AssessmentComment:  q.AssessmentComment.clone(db),
		AssessmentItem:     q.AssessmentItem.clone(db),
		DamageLevel:        q.DamageLevel.clone(db),
		Disaster:           q.Disaster.clone(db),
		DisasterDocument:   q.DisasterDocument.clone(db),
		EmailHistory:       q.EmailHistory.clone(db),
		FacilityEquipment:  q.FacilityEquipment.clone(db),
		FacilityType:       q.FacilityType.clone(db),
		GisDatum:           q.GisDatum.clone(db),
		Municipality:       q.Municipality.clone(db),
		Notification:       q.Notification.clone(db),
		Organization:       q.Organization.clone(db),
		Prefecture:         q.Prefecture.clone(db),
		Role:               q.Role.clone(db),
		SupportApplication: q.SupportApplication.clone(db),
		Timeline:           q.Timeline.clone(db),
		User:               q.User.clone(db),
		UserOrganization:   q.UserOrganization.clone(db),
	}
}

func (q *Query) ReadDB() *Query {
	return q.ReplaceDB(q.db.Clauses(dbresolver.Read))
}

func (q *Query) WriteDB() *Query {
	return q.ReplaceDB(q.db.Clauses(dbresolver.Write))
}

func (q *Query) ReplaceDB(db *gorm.DB) *Query {
	return &Query{
		db:                 db,
		Assessment:         q.Assessment.replaceDB(db),
		AssessmentComment:  q.AssessmentComment.replaceDB(db),
		AssessmentItem:     q.AssessmentItem.replaceDB(db),
		DamageLevel:        q.DamageLevel.replaceDB(db),
		Disaster:           q.Disaster.replaceDB(db),
		DisasterDocument:   q.DisasterDocument.replaceDB(db),
		EmailHistory:       q.EmailHistory.replaceDB(db),
		FacilityEquipment:  q.FacilityEquipment.replaceDB(db),
		FacilityType:       q.FacilityType.replaceDB(db),
		GisDatum:           q.GisDatum.replaceDB(db),
		Municipality:       q.Municipality.replaceDB(db),
		Notification:       q.Notification.replaceDB(db),
		Organization:       q.Organization.replaceDB(db),
		Prefecture:         q.Prefecture.replaceDB(db),
		Role:               q.Role.replaceDB(db),
		SupportApplication: q.SupportApplication.replaceDB(db),
		Timeline:           q.Timeline.replaceDB(db),
		User:               q.User.replaceDB(db),
		UserOrganization:   q.UserOrganization.replaceDB(db),
	}
}

type queryCtx struct {
	Assessment         IAssessmentDo
	AssessmentComment  IAssessmentCommentDo
	AssessmentItem     IAssessmentItemDo
	DamageLevel        IDamageLevelDo
	Disaster           IDisasterDo
	DisasterDocument   IDisasterDocumentDo
	EmailHistory       IEmailHistoryDo
	FacilityEquipment  IFacilityEquipmentDo
	FacilityType       IFacilityTypeDo
	GisDatum           IGisDatumDo
	Municipality       IMunicipalityDo
	Notification       INotificationDo
	Organization       IOrganizationDo
	Prefecture         IPrefectureDo
	Role               IRoleDo
	SupportApplication ISupportApplicationDo
	Timeline           ITimelineDo
	User               IUserDo
	UserOrganization   IUserOrganizationDo
}

func (q *Query) WithContext(ctx context.Context) *queryCtx {
	return &queryCtx{
		Assessment:         q.Assessment.WithContext(ctx),
		AssessmentComment:  q.AssessmentComment.WithContext(ctx),
		AssessmentItem:     q.AssessmentItem.WithContext(ctx),
		DamageLevel:        q.DamageLevel.WithContext(ctx),
		Disaster:           q.Disaster.WithContext(ctx),
		DisasterDocument:   q.DisasterDocument.WithContext(ctx),
		EmailHistory:       q.EmailHistory.WithContext(ctx),
		FacilityEquipment:  q.FacilityEquipment.WithContext(ctx),
		FacilityType:       q.FacilityType.WithContext(ctx),
		GisDatum:           q.GisDatum.WithContext(ctx),
		Municipality:       q.Municipality.WithContext(ctx),
		Notification:       q.Notification.WithContext(ctx),
		Organization:       q.Organization.WithContext(ctx),
		Prefecture:         q.Prefecture.WithContext(ctx),
		Role:               q.Role.WithContext(ctx),
		SupportApplication: q.SupportApplication.WithContext(ctx),
		Timeline:           q.Timeline.WithContext(ctx),
		User:               q.User.WithContext(ctx),
		UserOrganization:   q.UserOrganization.WithContext(ctx),
	}
}

func (q *Query) Transaction(fc func(tx *Query) error, opts ...*sql.TxOptions) error {
	return q.db.Transaction(func(tx *gorm.DB) error { return fc(q.clone(tx)) }, opts...)
}

func (q *Query) Begin(opts ...*sql.TxOptions) *QueryTx {
	tx := q.db.Begin(opts...)
	return &QueryTx{Query: q.clone(tx), Error: tx.Error}
}

type QueryTx struct {
	*Query
	Error error
}

func (q *QueryTx) Commit() error {
	return q.db.Commit().Error
}

func (q *QueryTx) Rollback() error {
	return q.db.Rollback().Error
}

func (q *QueryTx) SavePoint(name string) error {
	return q.db.SavePoint(name).Error
}

func (q *QueryTx) RollbackTo(name string) error {
	return q.db.RollbackTo(name).Error
}
