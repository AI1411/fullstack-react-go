// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/AI1411/fullstack-react-go/internal/domain/model"
)

func newDisaster(db *gorm.DB, opts ...gen.DOOption) disaster {
	_disaster := disaster{}

	_disaster.disasterDo.UseDB(db, opts...)
	_disaster.disasterDo.UseModel(&model.Disaster{})

	tableName := _disaster.disasterDo.TableName()
	_disaster.ALL = field.NewAsterisk(tableName)
	_disaster.ID = field.NewString(tableName, "id")
	_disaster.Name = field.NewString(tableName, "name")
	_disaster.MunicipalityID = field.NewInt32(tableName, "municipality_id")
	_disaster.OccurredAt = field.NewTime(tableName, "occurred_at")
	_disaster.Summary = field.NewString(tableName, "summary")
	_disaster.WorkCategoryID = field.NewInt64(tableName, "work_category_id")
	_disaster.Status = field.NewString(tableName, "status")
	_disaster.AffectedAreaSize = field.NewFloat64(tableName, "affected_area_size")
	_disaster.EstimatedDamageAmount = field.NewFloat64(tableName, "estimated_damage_amount")
	_disaster.Latitude = field.NewFloat64(tableName, "latitude")
	_disaster.Longitude = field.NewFloat64(tableName, "longitude")
	_disaster.Address = field.NewString(tableName, "address")
	_disaster.PlaceID = field.NewString(tableName, "place_id")
	_disaster.CreatedAt = field.NewTime(tableName, "created_at")
	_disaster.UpdatedAt = field.NewTime(tableName, "updated_at")
	_disaster.DeletedAt = field.NewField(tableName, "deleted_at")
	_disaster.Municipality = disasterBelongsToMunicipality{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("Municipality", "model.Municipality"),
	}

	_disaster.Timelines = disasterHasManyTimelines{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("Timelines", "model.Timeline"),
	}

	_disaster.DisasterDocuments = disasterHasManyDisasterDocuments{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("DisasterDocuments", "model.DisasterDocument"),
	}

	_disaster.WorkCategory = disasterBelongsToWorkCategory{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("WorkCategory", "model.WorkCategory"),
	}

	_disaster.fillFieldMap()

	return _disaster
}

type disaster struct {
	disasterDo

	ALL                   field.Asterisk
	ID                    field.String  // 災害ID - 主キー
	Name                  field.String  // 災害名 - 災害の名称
	MunicipalityID        field.Int32   // 自治体ID - 関連する自治体のID
	OccurredAt            field.Time    // 発生日時 - 災害が発生した日時
	Summary               field.String  // 被害概要 - 災害による被害の詳細説明
	WorkCategoryID        field.Int64   // 工種区分ID - 関連する作業カテゴリのID
	Status                field.String  // 状態 - pending(未着手), under_review(審査中), in_progress(対応中), completed(完了)のいずれか
	AffectedAreaSize      field.Float64 // 被害面積 - ヘクタール (ha) 単位での被害エリアの広さ
	EstimatedDamageAmount field.Float64 // 被害推定金額 - 円単位での被害総額
	Latitude              field.Float64 // 緯度 - 災害発生地点の緯度座標
	Longitude             field.Float64 // 経度 - 災害発生地点の経度座標
	Address               field.String  // 住所 - Google Maps APIから取得した住所情報
	PlaceID               field.String  // Google Place ID - Google Maps APIの場所識別子
	CreatedAt             field.Time    // 作成日時 - レコード作成日時
	UpdatedAt             field.Time    // 更新日時 - レコード最終更新日時
	DeletedAt             field.Field   // 削除日時 - 論理削除用のタイムスタンプ
	Municipality          disasterBelongsToMunicipality

	Timelines disasterHasManyTimelines

	DisasterDocuments disasterHasManyDisasterDocuments

	WorkCategory disasterBelongsToWorkCategory

	fieldMap map[string]field.Expr
}

func (d disaster) Table(newTableName string) *disaster {
	d.disasterDo.UseTable(newTableName)
	return d.updateTableName(newTableName)
}

func (d disaster) As(alias string) *disaster {
	d.disasterDo.DO = *(d.disasterDo.As(alias).(*gen.DO))
	return d.updateTableName(alias)
}

func (d *disaster) updateTableName(table string) *disaster {
	d.ALL = field.NewAsterisk(table)
	d.ID = field.NewString(table, "id")
	d.Name = field.NewString(table, "name")
	d.MunicipalityID = field.NewInt32(table, "municipality_id")
	d.OccurredAt = field.NewTime(table, "occurred_at")
	d.Summary = field.NewString(table, "summary")
	d.WorkCategoryID = field.NewInt64(table, "work_category_id")
	d.Status = field.NewString(table, "status")
	d.AffectedAreaSize = field.NewFloat64(table, "affected_area_size")
	d.EstimatedDamageAmount = field.NewFloat64(table, "estimated_damage_amount")
	d.Latitude = field.NewFloat64(table, "latitude")
	d.Longitude = field.NewFloat64(table, "longitude")
	d.Address = field.NewString(table, "address")
	d.PlaceID = field.NewString(table, "place_id")
	d.CreatedAt = field.NewTime(table, "created_at")
	d.UpdatedAt = field.NewTime(table, "updated_at")
	d.DeletedAt = field.NewField(table, "deleted_at")

	d.fillFieldMap()

	return d
}

func (d *disaster) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := d.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (d *disaster) fillFieldMap() {
	d.fieldMap = make(map[string]field.Expr, 20)
	d.fieldMap["id"] = d.ID
	d.fieldMap["name"] = d.Name
	d.fieldMap["municipality_id"] = d.MunicipalityID
	d.fieldMap["occurred_at"] = d.OccurredAt
	d.fieldMap["summary"] = d.Summary
	d.fieldMap["work_category_id"] = d.WorkCategoryID
	d.fieldMap["status"] = d.Status
	d.fieldMap["affected_area_size"] = d.AffectedAreaSize
	d.fieldMap["estimated_damage_amount"] = d.EstimatedDamageAmount
	d.fieldMap["latitude"] = d.Latitude
	d.fieldMap["longitude"] = d.Longitude
	d.fieldMap["address"] = d.Address
	d.fieldMap["place_id"] = d.PlaceID
	d.fieldMap["created_at"] = d.CreatedAt
	d.fieldMap["updated_at"] = d.UpdatedAt
	d.fieldMap["deleted_at"] = d.DeletedAt

}

func (d disaster) clone(db *gorm.DB) disaster {
	d.disasterDo.ReplaceConnPool(db.Statement.ConnPool)
	d.Municipality.db = db.Session(&gorm.Session{Initialized: true})
	d.Municipality.db.Statement.ConnPool = db.Statement.ConnPool
	d.Timelines.db = db.Session(&gorm.Session{Initialized: true})
	d.Timelines.db.Statement.ConnPool = db.Statement.ConnPool
	d.DisasterDocuments.db = db.Session(&gorm.Session{Initialized: true})
	d.DisasterDocuments.db.Statement.ConnPool = db.Statement.ConnPool
	d.WorkCategory.db = db.Session(&gorm.Session{Initialized: true})
	d.WorkCategory.db.Statement.ConnPool = db.Statement.ConnPool
	return d
}

func (d disaster) replaceDB(db *gorm.DB) disaster {
	d.disasterDo.ReplaceDB(db)
	d.Municipality.db = db.Session(&gorm.Session{})
	d.Timelines.db = db.Session(&gorm.Session{})
	d.DisasterDocuments.db = db.Session(&gorm.Session{})
	d.WorkCategory.db = db.Session(&gorm.Session{})
	return d
}

type disasterBelongsToMunicipality struct {
	db *gorm.DB

	field.RelationField
}

func (a disasterBelongsToMunicipality) Where(conds ...field.Expr) *disasterBelongsToMunicipality {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a disasterBelongsToMunicipality) WithContext(ctx context.Context) *disasterBelongsToMunicipality {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a disasterBelongsToMunicipality) Session(session *gorm.Session) *disasterBelongsToMunicipality {
	a.db = a.db.Session(session)
	return &a
}

func (a disasterBelongsToMunicipality) Model(m *model.Disaster) *disasterBelongsToMunicipalityTx {
	return &disasterBelongsToMunicipalityTx{a.db.Model(m).Association(a.Name())}
}

func (a disasterBelongsToMunicipality) Unscoped() *disasterBelongsToMunicipality {
	a.db = a.db.Unscoped()
	return &a
}

type disasterBelongsToMunicipalityTx struct{ tx *gorm.Association }

func (a disasterBelongsToMunicipalityTx) Find() (result *model.Municipality, err error) {
	return result, a.tx.Find(&result)
}

func (a disasterBelongsToMunicipalityTx) Append(values ...*model.Municipality) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a disasterBelongsToMunicipalityTx) Replace(values ...*model.Municipality) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a disasterBelongsToMunicipalityTx) Delete(values ...*model.Municipality) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a disasterBelongsToMunicipalityTx) Clear() error {
	return a.tx.Clear()
}

func (a disasterBelongsToMunicipalityTx) Count() int64 {
	return a.tx.Count()
}

func (a disasterBelongsToMunicipalityTx) Unscoped() *disasterBelongsToMunicipalityTx {
	a.tx = a.tx.Unscoped()
	return &a
}

type disasterHasManyTimelines struct {
	db *gorm.DB

	field.RelationField
}

func (a disasterHasManyTimelines) Where(conds ...field.Expr) *disasterHasManyTimelines {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a disasterHasManyTimelines) WithContext(ctx context.Context) *disasterHasManyTimelines {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a disasterHasManyTimelines) Session(session *gorm.Session) *disasterHasManyTimelines {
	a.db = a.db.Session(session)
	return &a
}

func (a disasterHasManyTimelines) Model(m *model.Disaster) *disasterHasManyTimelinesTx {
	return &disasterHasManyTimelinesTx{a.db.Model(m).Association(a.Name())}
}

func (a disasterHasManyTimelines) Unscoped() *disasterHasManyTimelines {
	a.db = a.db.Unscoped()
	return &a
}

type disasterHasManyTimelinesTx struct{ tx *gorm.Association }

func (a disasterHasManyTimelinesTx) Find() (result []*model.Timeline, err error) {
	return result, a.tx.Find(&result)
}

func (a disasterHasManyTimelinesTx) Append(values ...*model.Timeline) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a disasterHasManyTimelinesTx) Replace(values ...*model.Timeline) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a disasterHasManyTimelinesTx) Delete(values ...*model.Timeline) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a disasterHasManyTimelinesTx) Clear() error {
	return a.tx.Clear()
}

func (a disasterHasManyTimelinesTx) Count() int64 {
	return a.tx.Count()
}

func (a disasterHasManyTimelinesTx) Unscoped() *disasterHasManyTimelinesTx {
	a.tx = a.tx.Unscoped()
	return &a
}

type disasterHasManyDisasterDocuments struct {
	db *gorm.DB

	field.RelationField
}

func (a disasterHasManyDisasterDocuments) Where(conds ...field.Expr) *disasterHasManyDisasterDocuments {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a disasterHasManyDisasterDocuments) WithContext(ctx context.Context) *disasterHasManyDisasterDocuments {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a disasterHasManyDisasterDocuments) Session(session *gorm.Session) *disasterHasManyDisasterDocuments {
	a.db = a.db.Session(session)
	return &a
}

func (a disasterHasManyDisasterDocuments) Model(m *model.Disaster) *disasterHasManyDisasterDocumentsTx {
	return &disasterHasManyDisasterDocumentsTx{a.db.Model(m).Association(a.Name())}
}

func (a disasterHasManyDisasterDocuments) Unscoped() *disasterHasManyDisasterDocuments {
	a.db = a.db.Unscoped()
	return &a
}

type disasterHasManyDisasterDocumentsTx struct{ tx *gorm.Association }

func (a disasterHasManyDisasterDocumentsTx) Find() (result []*model.DisasterDocument, err error) {
	return result, a.tx.Find(&result)
}

func (a disasterHasManyDisasterDocumentsTx) Append(values ...*model.DisasterDocument) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a disasterHasManyDisasterDocumentsTx) Replace(values ...*model.DisasterDocument) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a disasterHasManyDisasterDocumentsTx) Delete(values ...*model.DisasterDocument) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a disasterHasManyDisasterDocumentsTx) Clear() error {
	return a.tx.Clear()
}

func (a disasterHasManyDisasterDocumentsTx) Count() int64 {
	return a.tx.Count()
}

func (a disasterHasManyDisasterDocumentsTx) Unscoped() *disasterHasManyDisasterDocumentsTx {
	a.tx = a.tx.Unscoped()
	return &a
}

type disasterBelongsToWorkCategory struct {
	db *gorm.DB

	field.RelationField
}

func (a disasterBelongsToWorkCategory) Where(conds ...field.Expr) *disasterBelongsToWorkCategory {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a disasterBelongsToWorkCategory) WithContext(ctx context.Context) *disasterBelongsToWorkCategory {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a disasterBelongsToWorkCategory) Session(session *gorm.Session) *disasterBelongsToWorkCategory {
	a.db = a.db.Session(session)
	return &a
}

func (a disasterBelongsToWorkCategory) Model(m *model.Disaster) *disasterBelongsToWorkCategoryTx {
	return &disasterBelongsToWorkCategoryTx{a.db.Model(m).Association(a.Name())}
}

func (a disasterBelongsToWorkCategory) Unscoped() *disasterBelongsToWorkCategory {
	a.db = a.db.Unscoped()
	return &a
}

type disasterBelongsToWorkCategoryTx struct{ tx *gorm.Association }

func (a disasterBelongsToWorkCategoryTx) Find() (result *model.WorkCategory, err error) {
	return result, a.tx.Find(&result)
}

func (a disasterBelongsToWorkCategoryTx) Append(values ...*model.WorkCategory) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a disasterBelongsToWorkCategoryTx) Replace(values ...*model.WorkCategory) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a disasterBelongsToWorkCategoryTx) Delete(values ...*model.WorkCategory) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a disasterBelongsToWorkCategoryTx) Clear() error {
	return a.tx.Clear()
}

func (a disasterBelongsToWorkCategoryTx) Count() int64 {
	return a.tx.Count()
}

func (a disasterBelongsToWorkCategoryTx) Unscoped() *disasterBelongsToWorkCategoryTx {
	a.tx = a.tx.Unscoped()
	return &a
}

type disasterDo struct{ gen.DO }

type IDisasterDo interface {
	gen.SubQuery
	Debug() IDisasterDo
	WithContext(ctx context.Context) IDisasterDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IDisasterDo
	WriteDB() IDisasterDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IDisasterDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IDisasterDo
	Not(conds ...gen.Condition) IDisasterDo
	Or(conds ...gen.Condition) IDisasterDo
	Select(conds ...field.Expr) IDisasterDo
	Where(conds ...gen.Condition) IDisasterDo
	Order(conds ...field.Expr) IDisasterDo
	Distinct(cols ...field.Expr) IDisasterDo
	Omit(cols ...field.Expr) IDisasterDo
	Join(table schema.Tabler, on ...field.Expr) IDisasterDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IDisasterDo
	RightJoin(table schema.Tabler, on ...field.Expr) IDisasterDo
	Group(cols ...field.Expr) IDisasterDo
	Having(conds ...gen.Condition) IDisasterDo
	Limit(limit int) IDisasterDo
	Offset(offset int) IDisasterDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IDisasterDo
	Unscoped() IDisasterDo
	Create(values ...*model.Disaster) error
	CreateInBatches(values []*model.Disaster, batchSize int) error
	Save(values ...*model.Disaster) error
	First() (*model.Disaster, error)
	Take() (*model.Disaster, error)
	Last() (*model.Disaster, error)
	Find() ([]*model.Disaster, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.Disaster, err error)
	FindInBatches(result *[]*model.Disaster, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.Disaster) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IDisasterDo
	Assign(attrs ...field.AssignExpr) IDisasterDo
	Joins(fields ...field.RelationField) IDisasterDo
	Preload(fields ...field.RelationField) IDisasterDo
	FirstOrInit() (*model.Disaster, error)
	FirstOrCreate() (*model.Disaster, error)
	FindByPage(offset int, limit int) (result []*model.Disaster, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IDisasterDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (d disasterDo) Debug() IDisasterDo {
	return d.withDO(d.DO.Debug())
}

func (d disasterDo) WithContext(ctx context.Context) IDisasterDo {
	return d.withDO(d.DO.WithContext(ctx))
}

func (d disasterDo) ReadDB() IDisasterDo {
	return d.Clauses(dbresolver.Read)
}

func (d disasterDo) WriteDB() IDisasterDo {
	return d.Clauses(dbresolver.Write)
}

func (d disasterDo) Session(config *gorm.Session) IDisasterDo {
	return d.withDO(d.DO.Session(config))
}

func (d disasterDo) Clauses(conds ...clause.Expression) IDisasterDo {
	return d.withDO(d.DO.Clauses(conds...))
}

func (d disasterDo) Returning(value interface{}, columns ...string) IDisasterDo {
	return d.withDO(d.DO.Returning(value, columns...))
}

func (d disasterDo) Not(conds ...gen.Condition) IDisasterDo {
	return d.withDO(d.DO.Not(conds...))
}

func (d disasterDo) Or(conds ...gen.Condition) IDisasterDo {
	return d.withDO(d.DO.Or(conds...))
}

func (d disasterDo) Select(conds ...field.Expr) IDisasterDo {
	return d.withDO(d.DO.Select(conds...))
}

func (d disasterDo) Where(conds ...gen.Condition) IDisasterDo {
	return d.withDO(d.DO.Where(conds...))
}

func (d disasterDo) Order(conds ...field.Expr) IDisasterDo {
	return d.withDO(d.DO.Order(conds...))
}

func (d disasterDo) Distinct(cols ...field.Expr) IDisasterDo {
	return d.withDO(d.DO.Distinct(cols...))
}

func (d disasterDo) Omit(cols ...field.Expr) IDisasterDo {
	return d.withDO(d.DO.Omit(cols...))
}

func (d disasterDo) Join(table schema.Tabler, on ...field.Expr) IDisasterDo {
	return d.withDO(d.DO.Join(table, on...))
}

func (d disasterDo) LeftJoin(table schema.Tabler, on ...field.Expr) IDisasterDo {
	return d.withDO(d.DO.LeftJoin(table, on...))
}

func (d disasterDo) RightJoin(table schema.Tabler, on ...field.Expr) IDisasterDo {
	return d.withDO(d.DO.RightJoin(table, on...))
}

func (d disasterDo) Group(cols ...field.Expr) IDisasterDo {
	return d.withDO(d.DO.Group(cols...))
}

func (d disasterDo) Having(conds ...gen.Condition) IDisasterDo {
	return d.withDO(d.DO.Having(conds...))
}

func (d disasterDo) Limit(limit int) IDisasterDo {
	return d.withDO(d.DO.Limit(limit))
}

func (d disasterDo) Offset(offset int) IDisasterDo {
	return d.withDO(d.DO.Offset(offset))
}

func (d disasterDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IDisasterDo {
	return d.withDO(d.DO.Scopes(funcs...))
}

func (d disasterDo) Unscoped() IDisasterDo {
	return d.withDO(d.DO.Unscoped())
}

func (d disasterDo) Create(values ...*model.Disaster) error {
	if len(values) == 0 {
		return nil
	}
	return d.DO.Create(values)
}

func (d disasterDo) CreateInBatches(values []*model.Disaster, batchSize int) error {
	return d.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (d disasterDo) Save(values ...*model.Disaster) error {
	if len(values) == 0 {
		return nil
	}
	return d.DO.Save(values)
}

func (d disasterDo) First() (*model.Disaster, error) {
	if result, err := d.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.Disaster), nil
	}
}

func (d disasterDo) Take() (*model.Disaster, error) {
	if result, err := d.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.Disaster), nil
	}
}

func (d disasterDo) Last() (*model.Disaster, error) {
	if result, err := d.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.Disaster), nil
	}
}

func (d disasterDo) Find() ([]*model.Disaster, error) {
	result, err := d.DO.Find()
	return result.([]*model.Disaster), err
}

func (d disasterDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.Disaster, err error) {
	buf := make([]*model.Disaster, 0, batchSize)
	err = d.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (d disasterDo) FindInBatches(result *[]*model.Disaster, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return d.DO.FindInBatches(result, batchSize, fc)
}

func (d disasterDo) Attrs(attrs ...field.AssignExpr) IDisasterDo {
	return d.withDO(d.DO.Attrs(attrs...))
}

func (d disasterDo) Assign(attrs ...field.AssignExpr) IDisasterDo {
	return d.withDO(d.DO.Assign(attrs...))
}

func (d disasterDo) Joins(fields ...field.RelationField) IDisasterDo {
	for _, _f := range fields {
		d = *d.withDO(d.DO.Joins(_f))
	}
	return &d
}

func (d disasterDo) Preload(fields ...field.RelationField) IDisasterDo {
	for _, _f := range fields {
		d = *d.withDO(d.DO.Preload(_f))
	}
	return &d
}

func (d disasterDo) FirstOrInit() (*model.Disaster, error) {
	if result, err := d.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.Disaster), nil
	}
}

func (d disasterDo) FirstOrCreate() (*model.Disaster, error) {
	if result, err := d.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.Disaster), nil
	}
}

func (d disasterDo) FindByPage(offset int, limit int) (result []*model.Disaster, count int64, err error) {
	result, err = d.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = d.Offset(-1).Limit(-1).Count()
	return
}

func (d disasterDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = d.Count()
	if err != nil {
		return
	}

	err = d.Offset(offset).Limit(limit).Scan(result)
	return
}

func (d disasterDo) Scan(result interface{}) (err error) {
	return d.DO.Scan(result)
}

func (d disasterDo) Delete(models ...*model.Disaster) (result gen.ResultInfo, err error) {
	return d.DO.Delete(models)
}

func (d *disasterDo) withDO(do gen.Dao) *disasterDo {
	d.DO = *do.(*gen.DO)
	return d
}
