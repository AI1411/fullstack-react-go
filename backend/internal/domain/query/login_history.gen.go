// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/AI1411/fullstack-react-go/internal/domain/model"
)

func newLoginHistory(db *gorm.DB, opts ...gen.DOOption) loginHistory {
	_loginHistory := loginHistory{}

	_loginHistory.loginHistoryDo.UseDB(db, opts...)
	_loginHistory.loginHistoryDo.UseModel(&model.LoginHistory{})

	tableName := _loginHistory.loginHistoryDo.TableName()
	_loginHistory.ALL = field.NewAsterisk(tableName)
	_loginHistory.ID = field.NewInt64(tableName, "id")
	_loginHistory.UserID = field.NewString(tableName, "user_id")
	_loginHistory.Username = field.NewString(tableName, "username")
	_loginHistory.LoginType = field.NewString(tableName, "login_type")
	_loginHistory.IPAddress = field.NewString(tableName, "ip_address")
	_loginHistory.UserAgent = field.NewString(tableName, "user_agent")
	_loginHistory.FailureReason = field.NewString(tableName, "failure_reason")
	_loginHistory.CreatedAt = field.NewTime(tableName, "created_at")

	_loginHistory.fillFieldMap()

	return _loginHistory
}

type loginHistory struct {
	loginHistoryDo

	ALL           field.Asterisk
	ID            field.Int64  // ログイン履歴ID（主キー、自動掲番）
	UserID        field.String // ユーザーID（外部キー、ユーザーテーブルのID）
	Username      field.String // ユーザー名（ユーザーが削除されても履歴を残すため）
	LoginType     field.String // ログインタイプ（成功: success、失敗: failed、ロック: locked、多要素認証必要: mfa_required）
	IPAddress     field.String // ユーザーのIPアドレス
	UserAgent     field.String // ユーザーエージェント情報（ブラウザやデバイス情報）
	FailureReason field.String // ログイン失敗理由（失敗時のみ）
	CreatedAt     field.Time   // ログイン履歴の作成日時

	fieldMap map[string]field.Expr
}

func (l loginHistory) Table(newTableName string) *loginHistory {
	l.loginHistoryDo.UseTable(newTableName)
	return l.updateTableName(newTableName)
}

func (l loginHistory) As(alias string) *loginHistory {
	l.loginHistoryDo.DO = *(l.loginHistoryDo.As(alias).(*gen.DO))
	return l.updateTableName(alias)
}

func (l *loginHistory) updateTableName(table string) *loginHistory {
	l.ALL = field.NewAsterisk(table)
	l.ID = field.NewInt64(table, "id")
	l.UserID = field.NewString(table, "user_id")
	l.Username = field.NewString(table, "username")
	l.LoginType = field.NewString(table, "login_type")
	l.IPAddress = field.NewString(table, "ip_address")
	l.UserAgent = field.NewString(table, "user_agent")
	l.FailureReason = field.NewString(table, "failure_reason")
	l.CreatedAt = field.NewTime(table, "created_at")

	l.fillFieldMap()

	return l
}

func (l *loginHistory) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := l.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (l *loginHistory) fillFieldMap() {
	l.fieldMap = make(map[string]field.Expr, 8)
	l.fieldMap["id"] = l.ID
	l.fieldMap["user_id"] = l.UserID
	l.fieldMap["username"] = l.Username
	l.fieldMap["login_type"] = l.LoginType
	l.fieldMap["ip_address"] = l.IPAddress
	l.fieldMap["user_agent"] = l.UserAgent
	l.fieldMap["failure_reason"] = l.FailureReason
	l.fieldMap["created_at"] = l.CreatedAt
}

func (l loginHistory) clone(db *gorm.DB) loginHistory {
	l.loginHistoryDo.ReplaceConnPool(db.Statement.ConnPool)
	return l
}

func (l loginHistory) replaceDB(db *gorm.DB) loginHistory {
	l.loginHistoryDo.ReplaceDB(db)
	return l
}

type loginHistoryDo struct{ gen.DO }

type ILoginHistoryDo interface {
	gen.SubQuery
	Debug() ILoginHistoryDo
	WithContext(ctx context.Context) ILoginHistoryDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ILoginHistoryDo
	WriteDB() ILoginHistoryDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ILoginHistoryDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ILoginHistoryDo
	Not(conds ...gen.Condition) ILoginHistoryDo
	Or(conds ...gen.Condition) ILoginHistoryDo
	Select(conds ...field.Expr) ILoginHistoryDo
	Where(conds ...gen.Condition) ILoginHistoryDo
	Order(conds ...field.Expr) ILoginHistoryDo
	Distinct(cols ...field.Expr) ILoginHistoryDo
	Omit(cols ...field.Expr) ILoginHistoryDo
	Join(table schema.Tabler, on ...field.Expr) ILoginHistoryDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ILoginHistoryDo
	RightJoin(table schema.Tabler, on ...field.Expr) ILoginHistoryDo
	Group(cols ...field.Expr) ILoginHistoryDo
	Having(conds ...gen.Condition) ILoginHistoryDo
	Limit(limit int) ILoginHistoryDo
	Offset(offset int) ILoginHistoryDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ILoginHistoryDo
	Unscoped() ILoginHistoryDo
	Create(values ...*model.LoginHistory) error
	CreateInBatches(values []*model.LoginHistory, batchSize int) error
	Save(values ...*model.LoginHistory) error
	First() (*model.LoginHistory, error)
	Take() (*model.LoginHistory, error)
	Last() (*model.LoginHistory, error)
	Find() ([]*model.LoginHistory, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.LoginHistory, err error)
	FindInBatches(result *[]*model.LoginHistory, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.LoginHistory) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ILoginHistoryDo
	Assign(attrs ...field.AssignExpr) ILoginHistoryDo
	Joins(fields ...field.RelationField) ILoginHistoryDo
	Preload(fields ...field.RelationField) ILoginHistoryDo
	FirstOrInit() (*model.LoginHistory, error)
	FirstOrCreate() (*model.LoginHistory, error)
	FindByPage(offset int, limit int) (result []*model.LoginHistory, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ILoginHistoryDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (l loginHistoryDo) Debug() ILoginHistoryDo {
	return l.withDO(l.DO.Debug())
}

func (l loginHistoryDo) WithContext(ctx context.Context) ILoginHistoryDo {
	return l.withDO(l.DO.WithContext(ctx))
}

func (l loginHistoryDo) ReadDB() ILoginHistoryDo {
	return l.Clauses(dbresolver.Read)
}

func (l loginHistoryDo) WriteDB() ILoginHistoryDo {
	return l.Clauses(dbresolver.Write)
}

func (l loginHistoryDo) Session(config *gorm.Session) ILoginHistoryDo {
	return l.withDO(l.DO.Session(config))
}

func (l loginHistoryDo) Clauses(conds ...clause.Expression) ILoginHistoryDo {
	return l.withDO(l.DO.Clauses(conds...))
}

func (l loginHistoryDo) Returning(value interface{}, columns ...string) ILoginHistoryDo {
	return l.withDO(l.DO.Returning(value, columns...))
}

func (l loginHistoryDo) Not(conds ...gen.Condition) ILoginHistoryDo {
	return l.withDO(l.DO.Not(conds...))
}

func (l loginHistoryDo) Or(conds ...gen.Condition) ILoginHistoryDo {
	return l.withDO(l.DO.Or(conds...))
}

func (l loginHistoryDo) Select(conds ...field.Expr) ILoginHistoryDo {
	return l.withDO(l.DO.Select(conds...))
}

func (l loginHistoryDo) Where(conds ...gen.Condition) ILoginHistoryDo {
	return l.withDO(l.DO.Where(conds...))
}

func (l loginHistoryDo) Order(conds ...field.Expr) ILoginHistoryDo {
	return l.withDO(l.DO.Order(conds...))
}

func (l loginHistoryDo) Distinct(cols ...field.Expr) ILoginHistoryDo {
	return l.withDO(l.DO.Distinct(cols...))
}

func (l loginHistoryDo) Omit(cols ...field.Expr) ILoginHistoryDo {
	return l.withDO(l.DO.Omit(cols...))
}

func (l loginHistoryDo) Join(table schema.Tabler, on ...field.Expr) ILoginHistoryDo {
	return l.withDO(l.DO.Join(table, on...))
}

func (l loginHistoryDo) LeftJoin(table schema.Tabler, on ...field.Expr) ILoginHistoryDo {
	return l.withDO(l.DO.LeftJoin(table, on...))
}

func (l loginHistoryDo) RightJoin(table schema.Tabler, on ...field.Expr) ILoginHistoryDo {
	return l.withDO(l.DO.RightJoin(table, on...))
}

func (l loginHistoryDo) Group(cols ...field.Expr) ILoginHistoryDo {
	return l.withDO(l.DO.Group(cols...))
}

func (l loginHistoryDo) Having(conds ...gen.Condition) ILoginHistoryDo {
	return l.withDO(l.DO.Having(conds...))
}

func (l loginHistoryDo) Limit(limit int) ILoginHistoryDo {
	return l.withDO(l.DO.Limit(limit))
}

func (l loginHistoryDo) Offset(offset int) ILoginHistoryDo {
	return l.withDO(l.DO.Offset(offset))
}

func (l loginHistoryDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ILoginHistoryDo {
	return l.withDO(l.DO.Scopes(funcs...))
}

func (l loginHistoryDo) Unscoped() ILoginHistoryDo {
	return l.withDO(l.DO.Unscoped())
}

func (l loginHistoryDo) Create(values ...*model.LoginHistory) error {
	if len(values) == 0 {
		return nil
	}
	return l.DO.Create(values)
}

func (l loginHistoryDo) CreateInBatches(values []*model.LoginHistory, batchSize int) error {
	return l.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (l loginHistoryDo) Save(values ...*model.LoginHistory) error {
	if len(values) == 0 {
		return nil
	}
	return l.DO.Save(values)
}

func (l loginHistoryDo) First() (*model.LoginHistory, error) {
	if result, err := l.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.LoginHistory), nil
	}
}

func (l loginHistoryDo) Take() (*model.LoginHistory, error) {
	if result, err := l.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.LoginHistory), nil
	}
}

func (l loginHistoryDo) Last() (*model.LoginHistory, error) {
	if result, err := l.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.LoginHistory), nil
	}
}

func (l loginHistoryDo) Find() ([]*model.LoginHistory, error) {
	result, err := l.DO.Find()
	return result.([]*model.LoginHistory), err
}

func (l loginHistoryDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.LoginHistory, err error) {
	buf := make([]*model.LoginHistory, 0, batchSize)
	err = l.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (l loginHistoryDo) FindInBatches(result *[]*model.LoginHistory, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return l.DO.FindInBatches(result, batchSize, fc)
}

func (l loginHistoryDo) Attrs(attrs ...field.AssignExpr) ILoginHistoryDo {
	return l.withDO(l.DO.Attrs(attrs...))
}

func (l loginHistoryDo) Assign(attrs ...field.AssignExpr) ILoginHistoryDo {
	return l.withDO(l.DO.Assign(attrs...))
}

func (l loginHistoryDo) Joins(fields ...field.RelationField) ILoginHistoryDo {
	for _, _f := range fields {
		l = *l.withDO(l.DO.Joins(_f))
	}
	return &l
}

func (l loginHistoryDo) Preload(fields ...field.RelationField) ILoginHistoryDo {
	for _, _f := range fields {
		l = *l.withDO(l.DO.Preload(_f))
	}
	return &l
}

func (l loginHistoryDo) FirstOrInit() (*model.LoginHistory, error) {
	if result, err := l.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.LoginHistory), nil
	}
}

func (l loginHistoryDo) FirstOrCreate() (*model.LoginHistory, error) {
	if result, err := l.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.LoginHistory), nil
	}
}

func (l loginHistoryDo) FindByPage(offset int, limit int) (result []*model.LoginHistory, count int64, err error) {
	result, err = l.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = l.Offset(-1).Limit(-1).Count()
	return
}

func (l loginHistoryDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = l.Count()
	if err != nil {
		return
	}

	err = l.Offset(offset).Limit(limit).Scan(result)
	return
}

func (l loginHistoryDo) Scan(result interface{}) (err error) {
	return l.DO.Scan(result)
}

func (l loginHistoryDo) Delete(models ...*model.LoginHistory) (result gen.ResultInfo, err error) {
	return l.DO.Delete(models)
}

func (l *loginHistoryDo) withDO(do gen.Dao) *loginHistoryDo {
	l.DO = *do.(*gen.DO)
	return l
}
