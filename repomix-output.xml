This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
backend/
  build/
    api/
      Dockerfile-dev
  cmd/
    api/
      main.go
    gormgen/
      generate_all/
        main.go
      generate_associations/
        main.go
  internal/
    domain/
      model/
        disasters.gen.go
        prefectures.gen.go
        regions.gen.go
        users.gen.go
      query/
        disasters.gen.go
        gen.go
        prefectures.gen.go
        regions.gen.go
        users.gen.go
    env/
      env.go
    handler/
      disaster_handler.go
    infra/
      database/
        connection.go
      datastore/
        disaster_repository.go
      db/
        client.go
      logger/
        logger.go
    middleware/
      cors.go
      logging.go
    usecase/
      disacter_usecase.go
  migrations/
    000001_create_users_table.up.sql
    000002_create_prefectures_and_regions_tables.up.sql
    000003_create_disasters_table.up.sql
  .air.toml
  .editorconfig
  .golangci.yml
  .pre-commit-config.yaml
  Dockerfile
  go.mod
  README.md
frontend/
  public/
    file.svg
    globe.svg
    next.svg
    vercel.svg
    window.svg
  src/
    api/
      model/
        handlerListDisastersResponse.ts
        index.ts
      client.msw.ts
      client.ts
    app/
      application/
        new/
          page.tsx
        page.tsx
      disasters/
        [id]/
          page.tsx
        page.tsx
      globals.css
      layout.tsx
      page.tsx
    components/
      layout/
        footer/
          page.tsx
        header/
          page.tsx
      ui/
        button.tsx
        error-display.tsx
        loading.tsx
      demo-component.tsx
    hooks/
      useErrorHandler.ts
    lib/
      api.ts
      providers.tsx
      store.ts
      utils.ts
  .gitignore
  biome.json
  components.json
  next.config.ts
  orval.config.js
  package.json
  postcss.config.mjs
  README.md
  tsconfig.json
.gitignore
docker-compose.yml
Makefile
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="frontend/src/components/ui/error-display.tsx">
import React from 'react'
import { AlertTriangle, RefreshCw } from 'lucide-react'

interface ErrorDisplayProps {
  title?: string
  message: string
  onRetry?: () => void
  className?: string
}

export const ErrorDisplay: React.FC<ErrorDisplayProps> = ({
  title = 'エラーが発生しました',
  message,
  onRetry,
  className = ''
}) => {
  return (
    <div className={`bg-red-50 border border-red-200 rounded-lg p-4 ${className}`}>
      <div className="flex items-start">
        <AlertTriangle className="h-5 w-5 text-red-400 mt-0.5 mr-3" />
        <div className="flex-1">
          <h3 className="text-red-800 font-medium text-sm">{title}</h3>
          <p className="text-red-600 text-sm mt-1">{message}</p>
          {onRetry && (
            <button
              onClick={onRetry}
              className="mt-3 inline-flex items-center px-3 py-1 bg-red-600 text-white text-sm rounded hover:bg-red-700 transition-colors"
            >
              <RefreshCw className="h-4 w-4 mr-1" />
              再試行
            </button>
          )}
        </div>
      </div>
    </div>
  )
}

interface EmptyStateProps {
  title: string
  description?: string
  icon?: React.ReactNode
  action?: React.ReactNode
  className?: string
}

export const EmptyState: React.FC<EmptyStateProps> = ({
  title,
  description,
  icon,
  action,
  className = ''
}) => {
  return (
    <div className={`text-center p-8 ${className}`}>
      {icon && (
        <div className="flex justify-center mb-4">
          {icon}
        </div>
      )}
      <h3 className="text-[#111418] font-medium text-lg mb-2">{title}</h3>
      {description && (
        <p className="text-[#637588] text-sm mb-4">{description}</p>
      )}
      {action && action}
    </div>
  )
}
</file>

<file path="frontend/src/components/ui/loading.tsx">
import React from 'react'

interface LoadingSpinnerProps {
  size?: 'sm' | 'md' | 'lg'
  message?: string
  className?: string
}

export const LoadingSpinner: React.FC<LoadingSpinnerProps> = ({
  size = 'md',
  message,
  className = ''
}) => {
  const sizeClasses = {
    sm: 'h-4 w-4',
    md: 'h-8 w-8',
    lg: 'h-12 w-12'
  }

  return (
    <div className={`flex items-center justify-center ${className}`}>
      <div
        className={`animate-spin rounded-full border-b-2 border-[#111418] ${sizeClasses[size]}`}
      />
      {message && (
        <span className="ml-2 text-[#637588] text-sm">{message}</span>
      )}
    </div>
  )
}

interface LoadingTableProps {
  rows?: number
  columns?: number
}

export const LoadingTable: React.FC<LoadingTableProps> = ({
  rows = 5,
  columns = 4
}) => {
  return (
    <div className="animate-pulse">
      {/* ヘッダー */}
      <div className="flex space-x-4 mb-4">
        {Array.from({ length: columns }, (_, i) => (
          <div key={i} className="bg-gray-200 h-6 rounded flex-1" />
        ))}
      </div>
      {/* 行 */}
      <div className="space-y-2">
        {Array.from({ length: rows }, (_, i) => (
          <div key={i} className="flex space-x-4">
            {Array.from({ length: columns }, (_, j) => (
              <div key={j} className="bg-gray-200 h-16 rounded flex-1" />
            ))}
          </div>
        ))}
      </div>
    </div>
  )
}

interface LoadingCardProps {
  count?: number
}

export const LoadingCard: React.FC<LoadingCardProps> = ({ count = 3 }) => {
  return (
    <div className="flex flex-wrap gap-4">
      {Array.from({ length: count }, (_, i) => (
        <div key={i} className="flex min-w-[158px] flex-1 flex-col gap-2 rounded-lg p-6 border border-[#dce0e5]">
          <div className="animate-pulse">
            <div className="bg-gray-200 h-4 rounded mb-2" />
            <div className="bg-gray-200 h-8 rounded" />
          </div>
        </div>
      ))}
    </div>
  )
}
</file>

<file path="frontend/src/hooks/useErrorHandler.ts">
import { useCallback } from 'react'
import { AxiosError } from 'axios'

export interface ApiError {
  message: string
  status?: number
  code?: string
}

export const useErrorHandler = () => {
  const handleError = useCallback((error: unknown): ApiError => {
    if (error instanceof AxiosError) {
      // Axiosエラーの場合
      if (error.response) {
        // サーバーからのレスポンスがある場合
        return {
          message: error.response.data?.message || error.message || 'サーバーエラーが発生しました',
          status: error.response.status,
          code: error.response.data?.code || error.code
        }
      } else if (error.request) {
        // リクエストは送信されたがレスポンスがない場合
        return {
          message: 'サーバーに接続できませんでした',
          status: undefined,
          code: 'NETWORK_ERROR'
        }
      } else {
        // リクエスト設定でエラーが発生した場合
        return {
          message: error.message || '不明なエラーが発生しました',
          status: undefined,
          code: 'REQUEST_ERROR'
        }
      }
    }

    // その他のエラー
    if (error instanceof Error) {
      return {
        message: error.message,
        status: undefined,
        code: 'UNKNOWN_ERROR'
      }
    }

    return {
      message: '不明なエラーが発生しました',
      status: undefined,
      code: 'UNKNOWN_ERROR'
    }
  }, [])

  return { handleError }
}
</file>

<file path="backend/build/api/Dockerfile-dev">
## Dockerfile for development
FROM golang:1.24

WORKDIR /go/src/
RUN go install github.com/cosmtrek/air@v1.49.0 && go install github.com/swaggo/swag/cmd/swag@latest
CMD ["air", "-c", ".air.toml"]

EXPOSE 8080
</file>

<file path="backend/internal/domain/model/prefectures.gen.go">
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package model

const TableNamePrefecture = "prefectures"

// Prefecture mapped from table <prefectures>
type Prefecture struct {
	ID       int32  `gorm:"column:id;type:integer;primaryKey;autoIncrement:true;comment:都道府県名" json:"id"`                                    // 都道府県名
	Name     string `gorm:"column:name;type:character varying(10);not null;index:idx_prefectures_name,priority:1;comment:都道府県名" json:"name"` // 都道府県名
	RegionID int32  `gorm:"column:region_id;type:integer;not null;index:idx_prefectures_region_id,priority:1;comment:地域ID" json:"region_id"` // 地域ID
}

// TableName Prefecture's table name
func (*Prefecture) TableName() string {
	return TableNamePrefecture
}
</file>

<file path="backend/internal/domain/model/regions.gen.go">
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package model

const TableNameRegion = "regions"

// Region mapped from table <regions>
type Region struct {
	ID   int32  `gorm:"column:id;type:integer;primaryKey;autoIncrement:true;comment:地域ID" json:"id"`                               // 地域ID
	Name string `gorm:"column:name;type:character varying(50);not null;index:idx_regions_name,priority:1;comment:地域名" json:"name"` // 地域名
}

// TableName Region's table name
func (*Region) TableName() string {
	return TableNameRegion
}
</file>

<file path="backend/internal/domain/model/users.gen.go">
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package model

import (
	"time"

	"gorm.io/gorm"
)

const TableNameUser = "users"

// User mapped from table <users>
type User struct {
	ID        int32          `gorm:"column:id;type:integer;primaryKey;autoIncrement:true" json:"id"`
	Name      string         `gorm:"column:name;type:character varying(255);not null" json:"name"`
	Email     string         `gorm:"column:email;type:character varying(255);not null;index:idx_users_email,priority:1" json:"email"`
	Password  string         `gorm:"column:password;type:character varying(255);not null" json:"password"`
	CreatedAt *time.Time     `gorm:"column:created_at;type:timestamp with time zone;default:CURRENT_TIMESTAMP" json:"created_at"`
	UpdatedAt *time.Time     `gorm:"column:updated_at;type:timestamp with time zone;default:CURRENT_TIMESTAMP" json:"updated_at"`
	DeletedAt gorm.DeletedAt `gorm:"column:deleted_at;type:timestamp with time zone;index:idx_users_deleted_at,priority:1" json:"deleted_at"`
}

// TableName User's table name
func (*User) TableName() string {
	return TableNameUser
}
</file>

<file path="backend/internal/domain/query/prefectures.gen.go">
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/AI1411/fullstack-react-go/internal/domain/model"
)

func newPrefecture(db *gorm.DB, opts ...gen.DOOption) prefecture {
	_prefecture := prefecture{}

	_prefecture.prefectureDo.UseDB(db, opts...)
	_prefecture.prefectureDo.UseModel(&model.Prefecture{})

	tableName := _prefecture.prefectureDo.TableName()
	_prefecture.ALL = field.NewAsterisk(tableName)
	_prefecture.ID = field.NewInt32(tableName, "id")
	_prefecture.Name = field.NewString(tableName, "name")
	_prefecture.RegionID = field.NewInt32(tableName, "region_id")

	_prefecture.fillFieldMap()

	return _prefecture
}

type prefecture struct {
	prefectureDo

	ALL      field.Asterisk
	ID       field.Int32  // 都道府県名
	Name     field.String // 都道府県名
	RegionID field.Int32  // 地域ID

	fieldMap map[string]field.Expr
}

func (p prefecture) Table(newTableName string) *prefecture {
	p.prefectureDo.UseTable(newTableName)
	return p.updateTableName(newTableName)
}

func (p prefecture) As(alias string) *prefecture {
	p.prefectureDo.DO = *(p.prefectureDo.As(alias).(*gen.DO))
	return p.updateTableName(alias)
}

func (p *prefecture) updateTableName(table string) *prefecture {
	p.ALL = field.NewAsterisk(table)
	p.ID = field.NewInt32(table, "id")
	p.Name = field.NewString(table, "name")
	p.RegionID = field.NewInt32(table, "region_id")

	p.fillFieldMap()

	return p
}

func (p *prefecture) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := p.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (p *prefecture) fillFieldMap() {
	p.fieldMap = make(map[string]field.Expr, 3)
	p.fieldMap["id"] = p.ID
	p.fieldMap["name"] = p.Name
	p.fieldMap["region_id"] = p.RegionID
}

func (p prefecture) clone(db *gorm.DB) prefecture {
	p.prefectureDo.ReplaceConnPool(db.Statement.ConnPool)
	return p
}

func (p prefecture) replaceDB(db *gorm.DB) prefecture {
	p.prefectureDo.ReplaceDB(db)
	return p
}

type prefectureDo struct{ gen.DO }

type IPrefectureDo interface {
	gen.SubQuery
	Debug() IPrefectureDo
	WithContext(ctx context.Context) IPrefectureDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IPrefectureDo
	WriteDB() IPrefectureDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IPrefectureDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IPrefectureDo
	Not(conds ...gen.Condition) IPrefectureDo
	Or(conds ...gen.Condition) IPrefectureDo
	Select(conds ...field.Expr) IPrefectureDo
	Where(conds ...gen.Condition) IPrefectureDo
	Order(conds ...field.Expr) IPrefectureDo
	Distinct(cols ...field.Expr) IPrefectureDo
	Omit(cols ...field.Expr) IPrefectureDo
	Join(table schema.Tabler, on ...field.Expr) IPrefectureDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IPrefectureDo
	RightJoin(table schema.Tabler, on ...field.Expr) IPrefectureDo
	Group(cols ...field.Expr) IPrefectureDo
	Having(conds ...gen.Condition) IPrefectureDo
	Limit(limit int) IPrefectureDo
	Offset(offset int) IPrefectureDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IPrefectureDo
	Unscoped() IPrefectureDo
	Create(values ...*model.Prefecture) error
	CreateInBatches(values []*model.Prefecture, batchSize int) error
	Save(values ...*model.Prefecture) error
	First() (*model.Prefecture, error)
	Take() (*model.Prefecture, error)
	Last() (*model.Prefecture, error)
	Find() ([]*model.Prefecture, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.Prefecture, err error)
	FindInBatches(result *[]*model.Prefecture, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.Prefecture) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IPrefectureDo
	Assign(attrs ...field.AssignExpr) IPrefectureDo
	Joins(fields ...field.RelationField) IPrefectureDo
	Preload(fields ...field.RelationField) IPrefectureDo
	FirstOrInit() (*model.Prefecture, error)
	FirstOrCreate() (*model.Prefecture, error)
	FindByPage(offset int, limit int) (result []*model.Prefecture, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IPrefectureDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (p prefectureDo) Debug() IPrefectureDo {
	return p.withDO(p.DO.Debug())
}

func (p prefectureDo) WithContext(ctx context.Context) IPrefectureDo {
	return p.withDO(p.DO.WithContext(ctx))
}

func (p prefectureDo) ReadDB() IPrefectureDo {
	return p.Clauses(dbresolver.Read)
}

func (p prefectureDo) WriteDB() IPrefectureDo {
	return p.Clauses(dbresolver.Write)
}

func (p prefectureDo) Session(config *gorm.Session) IPrefectureDo {
	return p.withDO(p.DO.Session(config))
}

func (p prefectureDo) Clauses(conds ...clause.Expression) IPrefectureDo {
	return p.withDO(p.DO.Clauses(conds...))
}

func (p prefectureDo) Returning(value interface{}, columns ...string) IPrefectureDo {
	return p.withDO(p.DO.Returning(value, columns...))
}

func (p prefectureDo) Not(conds ...gen.Condition) IPrefectureDo {
	return p.withDO(p.DO.Not(conds...))
}

func (p prefectureDo) Or(conds ...gen.Condition) IPrefectureDo {
	return p.withDO(p.DO.Or(conds...))
}

func (p prefectureDo) Select(conds ...field.Expr) IPrefectureDo {
	return p.withDO(p.DO.Select(conds...))
}

func (p prefectureDo) Where(conds ...gen.Condition) IPrefectureDo {
	return p.withDO(p.DO.Where(conds...))
}

func (p prefectureDo) Order(conds ...field.Expr) IPrefectureDo {
	return p.withDO(p.DO.Order(conds...))
}

func (p prefectureDo) Distinct(cols ...field.Expr) IPrefectureDo {
	return p.withDO(p.DO.Distinct(cols...))
}

func (p prefectureDo) Omit(cols ...field.Expr) IPrefectureDo {
	return p.withDO(p.DO.Omit(cols...))
}

func (p prefectureDo) Join(table schema.Tabler, on ...field.Expr) IPrefectureDo {
	return p.withDO(p.DO.Join(table, on...))
}

func (p prefectureDo) LeftJoin(table schema.Tabler, on ...field.Expr) IPrefectureDo {
	return p.withDO(p.DO.LeftJoin(table, on...))
}

func (p prefectureDo) RightJoin(table schema.Tabler, on ...field.Expr) IPrefectureDo {
	return p.withDO(p.DO.RightJoin(table, on...))
}

func (p prefectureDo) Group(cols ...field.Expr) IPrefectureDo {
	return p.withDO(p.DO.Group(cols...))
}

func (p prefectureDo) Having(conds ...gen.Condition) IPrefectureDo {
	return p.withDO(p.DO.Having(conds...))
}

func (p prefectureDo) Limit(limit int) IPrefectureDo {
	return p.withDO(p.DO.Limit(limit))
}

func (p prefectureDo) Offset(offset int) IPrefectureDo {
	return p.withDO(p.DO.Offset(offset))
}

func (p prefectureDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IPrefectureDo {
	return p.withDO(p.DO.Scopes(funcs...))
}

func (p prefectureDo) Unscoped() IPrefectureDo {
	return p.withDO(p.DO.Unscoped())
}

func (p prefectureDo) Create(values ...*model.Prefecture) error {
	if len(values) == 0 {
		return nil
	}
	return p.DO.Create(values)
}

func (p prefectureDo) CreateInBatches(values []*model.Prefecture, batchSize int) error {
	return p.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (p prefectureDo) Save(values ...*model.Prefecture) error {
	if len(values) == 0 {
		return nil
	}
	return p.DO.Save(values)
}

func (p prefectureDo) First() (*model.Prefecture, error) {
	if result, err := p.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.Prefecture), nil
	}
}

func (p prefectureDo) Take() (*model.Prefecture, error) {
	if result, err := p.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.Prefecture), nil
	}
}

func (p prefectureDo) Last() (*model.Prefecture, error) {
	if result, err := p.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.Prefecture), nil
	}
}

func (p prefectureDo) Find() ([]*model.Prefecture, error) {
	result, err := p.DO.Find()
	return result.([]*model.Prefecture), err
}

func (p prefectureDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.Prefecture, err error) {
	buf := make([]*model.Prefecture, 0, batchSize)
	err = p.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (p prefectureDo) FindInBatches(result *[]*model.Prefecture, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return p.DO.FindInBatches(result, batchSize, fc)
}

func (p prefectureDo) Attrs(attrs ...field.AssignExpr) IPrefectureDo {
	return p.withDO(p.DO.Attrs(attrs...))
}

func (p prefectureDo) Assign(attrs ...field.AssignExpr) IPrefectureDo {
	return p.withDO(p.DO.Assign(attrs...))
}

func (p prefectureDo) Joins(fields ...field.RelationField) IPrefectureDo {
	for _, _f := range fields {
		p = *p.withDO(p.DO.Joins(_f))
	}
	return &p
}

func (p prefectureDo) Preload(fields ...field.RelationField) IPrefectureDo {
	for _, _f := range fields {
		p = *p.withDO(p.DO.Preload(_f))
	}
	return &p
}

func (p prefectureDo) FirstOrInit() (*model.Prefecture, error) {
	if result, err := p.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.Prefecture), nil
	}
}

func (p prefectureDo) FirstOrCreate() (*model.Prefecture, error) {
	if result, err := p.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.Prefecture), nil
	}
}

func (p prefectureDo) FindByPage(offset int, limit int) (result []*model.Prefecture, count int64, err error) {
	result, err = p.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = p.Offset(-1).Limit(-1).Count()
	return
}

func (p prefectureDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = p.Count()
	if err != nil {
		return
	}

	err = p.Offset(offset).Limit(limit).Scan(result)
	return
}

func (p prefectureDo) Scan(result interface{}) (err error) {
	return p.DO.Scan(result)
}

func (p prefectureDo) Delete(models ...*model.Prefecture) (result gen.ResultInfo, err error) {
	return p.DO.Delete(models)
}

func (p *prefectureDo) withDO(do gen.Dao) *prefectureDo {
	p.DO = *do.(*gen.DO)
	return p
}
</file>

<file path="backend/internal/domain/query/regions.gen.go">
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/AI1411/fullstack-react-go/internal/domain/model"
)

func newRegion(db *gorm.DB, opts ...gen.DOOption) region {
	_region := region{}

	_region.regionDo.UseDB(db, opts...)
	_region.regionDo.UseModel(&model.Region{})

	tableName := _region.regionDo.TableName()
	_region.ALL = field.NewAsterisk(tableName)
	_region.ID = field.NewInt32(tableName, "id")
	_region.Name = field.NewString(tableName, "name")

	_region.fillFieldMap()

	return _region
}

type region struct {
	regionDo

	ALL  field.Asterisk
	ID   field.Int32  // 地域ID
	Name field.String // 地域名

	fieldMap map[string]field.Expr
}

func (r region) Table(newTableName string) *region {
	r.regionDo.UseTable(newTableName)
	return r.updateTableName(newTableName)
}

func (r region) As(alias string) *region {
	r.regionDo.DO = *(r.regionDo.As(alias).(*gen.DO))
	return r.updateTableName(alias)
}

func (r *region) updateTableName(table string) *region {
	r.ALL = field.NewAsterisk(table)
	r.ID = field.NewInt32(table, "id")
	r.Name = field.NewString(table, "name")

	r.fillFieldMap()

	return r
}

func (r *region) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := r.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (r *region) fillFieldMap() {
	r.fieldMap = make(map[string]field.Expr, 2)
	r.fieldMap["id"] = r.ID
	r.fieldMap["name"] = r.Name
}

func (r region) clone(db *gorm.DB) region {
	r.regionDo.ReplaceConnPool(db.Statement.ConnPool)
	return r
}

func (r region) replaceDB(db *gorm.DB) region {
	r.regionDo.ReplaceDB(db)
	return r
}

type regionDo struct{ gen.DO }

type IRegionDo interface {
	gen.SubQuery
	Debug() IRegionDo
	WithContext(ctx context.Context) IRegionDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IRegionDo
	WriteDB() IRegionDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IRegionDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IRegionDo
	Not(conds ...gen.Condition) IRegionDo
	Or(conds ...gen.Condition) IRegionDo
	Select(conds ...field.Expr) IRegionDo
	Where(conds ...gen.Condition) IRegionDo
	Order(conds ...field.Expr) IRegionDo
	Distinct(cols ...field.Expr) IRegionDo
	Omit(cols ...field.Expr) IRegionDo
	Join(table schema.Tabler, on ...field.Expr) IRegionDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IRegionDo
	RightJoin(table schema.Tabler, on ...field.Expr) IRegionDo
	Group(cols ...field.Expr) IRegionDo
	Having(conds ...gen.Condition) IRegionDo
	Limit(limit int) IRegionDo
	Offset(offset int) IRegionDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IRegionDo
	Unscoped() IRegionDo
	Create(values ...*model.Region) error
	CreateInBatches(values []*model.Region, batchSize int) error
	Save(values ...*model.Region) error
	First() (*model.Region, error)
	Take() (*model.Region, error)
	Last() (*model.Region, error)
	Find() ([]*model.Region, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.Region, err error)
	FindInBatches(result *[]*model.Region, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.Region) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IRegionDo
	Assign(attrs ...field.AssignExpr) IRegionDo
	Joins(fields ...field.RelationField) IRegionDo
	Preload(fields ...field.RelationField) IRegionDo
	FirstOrInit() (*model.Region, error)
	FirstOrCreate() (*model.Region, error)
	FindByPage(offset int, limit int) (result []*model.Region, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IRegionDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (r regionDo) Debug() IRegionDo {
	return r.withDO(r.DO.Debug())
}

func (r regionDo) WithContext(ctx context.Context) IRegionDo {
	return r.withDO(r.DO.WithContext(ctx))
}

func (r regionDo) ReadDB() IRegionDo {
	return r.Clauses(dbresolver.Read)
}

func (r regionDo) WriteDB() IRegionDo {
	return r.Clauses(dbresolver.Write)
}

func (r regionDo) Session(config *gorm.Session) IRegionDo {
	return r.withDO(r.DO.Session(config))
}

func (r regionDo) Clauses(conds ...clause.Expression) IRegionDo {
	return r.withDO(r.DO.Clauses(conds...))
}

func (r regionDo) Returning(value interface{}, columns ...string) IRegionDo {
	return r.withDO(r.DO.Returning(value, columns...))
}

func (r regionDo) Not(conds ...gen.Condition) IRegionDo {
	return r.withDO(r.DO.Not(conds...))
}

func (r regionDo) Or(conds ...gen.Condition) IRegionDo {
	return r.withDO(r.DO.Or(conds...))
}

func (r regionDo) Select(conds ...field.Expr) IRegionDo {
	return r.withDO(r.DO.Select(conds...))
}

func (r regionDo) Where(conds ...gen.Condition) IRegionDo {
	return r.withDO(r.DO.Where(conds...))
}

func (r regionDo) Order(conds ...field.Expr) IRegionDo {
	return r.withDO(r.DO.Order(conds...))
}

func (r regionDo) Distinct(cols ...field.Expr) IRegionDo {
	return r.withDO(r.DO.Distinct(cols...))
}

func (r regionDo) Omit(cols ...field.Expr) IRegionDo {
	return r.withDO(r.DO.Omit(cols...))
}

func (r regionDo) Join(table schema.Tabler, on ...field.Expr) IRegionDo {
	return r.withDO(r.DO.Join(table, on...))
}

func (r regionDo) LeftJoin(table schema.Tabler, on ...field.Expr) IRegionDo {
	return r.withDO(r.DO.LeftJoin(table, on...))
}

func (r regionDo) RightJoin(table schema.Tabler, on ...field.Expr) IRegionDo {
	return r.withDO(r.DO.RightJoin(table, on...))
}

func (r regionDo) Group(cols ...field.Expr) IRegionDo {
	return r.withDO(r.DO.Group(cols...))
}

func (r regionDo) Having(conds ...gen.Condition) IRegionDo {
	return r.withDO(r.DO.Having(conds...))
}

func (r regionDo) Limit(limit int) IRegionDo {
	return r.withDO(r.DO.Limit(limit))
}

func (r regionDo) Offset(offset int) IRegionDo {
	return r.withDO(r.DO.Offset(offset))
}

func (r regionDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IRegionDo {
	return r.withDO(r.DO.Scopes(funcs...))
}

func (r regionDo) Unscoped() IRegionDo {
	return r.withDO(r.DO.Unscoped())
}

func (r regionDo) Create(values ...*model.Region) error {
	if len(values) == 0 {
		return nil
	}
	return r.DO.Create(values)
}

func (r regionDo) CreateInBatches(values []*model.Region, batchSize int) error {
	return r.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (r regionDo) Save(values ...*model.Region) error {
	if len(values) == 0 {
		return nil
	}
	return r.DO.Save(values)
}

func (r regionDo) First() (*model.Region, error) {
	if result, err := r.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.Region), nil
	}
}

func (r regionDo) Take() (*model.Region, error) {
	if result, err := r.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.Region), nil
	}
}

func (r regionDo) Last() (*model.Region, error) {
	if result, err := r.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.Region), nil
	}
}

func (r regionDo) Find() ([]*model.Region, error) {
	result, err := r.DO.Find()
	return result.([]*model.Region), err
}

func (r regionDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.Region, err error) {
	buf := make([]*model.Region, 0, batchSize)
	err = r.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (r regionDo) FindInBatches(result *[]*model.Region, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return r.DO.FindInBatches(result, batchSize, fc)
}

func (r regionDo) Attrs(attrs ...field.AssignExpr) IRegionDo {
	return r.withDO(r.DO.Attrs(attrs...))
}

func (r regionDo) Assign(attrs ...field.AssignExpr) IRegionDo {
	return r.withDO(r.DO.Assign(attrs...))
}

func (r regionDo) Joins(fields ...field.RelationField) IRegionDo {
	for _, _f := range fields {
		r = *r.withDO(r.DO.Joins(_f))
	}
	return &r
}

func (r regionDo) Preload(fields ...field.RelationField) IRegionDo {
	for _, _f := range fields {
		r = *r.withDO(r.DO.Preload(_f))
	}
	return &r
}

func (r regionDo) FirstOrInit() (*model.Region, error) {
	if result, err := r.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.Region), nil
	}
}

func (r regionDo) FirstOrCreate() (*model.Region, error) {
	if result, err := r.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.Region), nil
	}
}

func (r regionDo) FindByPage(offset int, limit int) (result []*model.Region, count int64, err error) {
	result, err = r.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = r.Offset(-1).Limit(-1).Count()
	return
}

func (r regionDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = r.Count()
	if err != nil {
		return
	}

	err = r.Offset(offset).Limit(limit).Scan(result)
	return
}

func (r regionDo) Scan(result interface{}) (err error) {
	return r.DO.Scan(result)
}

func (r regionDo) Delete(models ...*model.Region) (result gen.ResultInfo, err error) {
	return r.DO.Delete(models)
}

func (r *regionDo) withDO(do gen.Dao) *regionDo {
	r.DO = *do.(*gen.DO)
	return r
}
</file>

<file path="backend/internal/domain/query/users.gen.go">
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/AI1411/fullstack-react-go/internal/domain/model"
)

func newUser(db *gorm.DB, opts ...gen.DOOption) user {
	_user := user{}

	_user.userDo.UseDB(db, opts...)
	_user.userDo.UseModel(&model.User{})

	tableName := _user.userDo.TableName()
	_user.ALL = field.NewAsterisk(tableName)
	_user.ID = field.NewInt32(tableName, "id")
	_user.Name = field.NewString(tableName, "name")
	_user.Email = field.NewString(tableName, "email")
	_user.Password = field.NewString(tableName, "password")
	_user.CreatedAt = field.NewTime(tableName, "created_at")
	_user.UpdatedAt = field.NewTime(tableName, "updated_at")
	_user.DeletedAt = field.NewField(tableName, "deleted_at")

	_user.fillFieldMap()

	return _user
}

type user struct {
	userDo

	ALL       field.Asterisk
	ID        field.Int32
	Name      field.String
	Email     field.String
	Password  field.String
	CreatedAt field.Time
	UpdatedAt field.Time
	DeletedAt field.Field

	fieldMap map[string]field.Expr
}

func (u user) Table(newTableName string) *user {
	u.userDo.UseTable(newTableName)
	return u.updateTableName(newTableName)
}

func (u user) As(alias string) *user {
	u.userDo.DO = *(u.userDo.As(alias).(*gen.DO))
	return u.updateTableName(alias)
}

func (u *user) updateTableName(table string) *user {
	u.ALL = field.NewAsterisk(table)
	u.ID = field.NewInt32(table, "id")
	u.Name = field.NewString(table, "name")
	u.Email = field.NewString(table, "email")
	u.Password = field.NewString(table, "password")
	u.CreatedAt = field.NewTime(table, "created_at")
	u.UpdatedAt = field.NewTime(table, "updated_at")
	u.DeletedAt = field.NewField(table, "deleted_at")

	u.fillFieldMap()

	return u
}

func (u *user) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := u.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (u *user) fillFieldMap() {
	u.fieldMap = make(map[string]field.Expr, 7)
	u.fieldMap["id"] = u.ID
	u.fieldMap["name"] = u.Name
	u.fieldMap["email"] = u.Email
	u.fieldMap["password"] = u.Password
	u.fieldMap["created_at"] = u.CreatedAt
	u.fieldMap["updated_at"] = u.UpdatedAt
	u.fieldMap["deleted_at"] = u.DeletedAt
}

func (u user) clone(db *gorm.DB) user {
	u.userDo.ReplaceConnPool(db.Statement.ConnPool)
	return u
}

func (u user) replaceDB(db *gorm.DB) user {
	u.userDo.ReplaceDB(db)
	return u
}

type userDo struct{ gen.DO }

type IUserDo interface {
	gen.SubQuery
	Debug() IUserDo
	WithContext(ctx context.Context) IUserDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IUserDo
	WriteDB() IUserDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IUserDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IUserDo
	Not(conds ...gen.Condition) IUserDo
	Or(conds ...gen.Condition) IUserDo
	Select(conds ...field.Expr) IUserDo
	Where(conds ...gen.Condition) IUserDo
	Order(conds ...field.Expr) IUserDo
	Distinct(cols ...field.Expr) IUserDo
	Omit(cols ...field.Expr) IUserDo
	Join(table schema.Tabler, on ...field.Expr) IUserDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IUserDo
	RightJoin(table schema.Tabler, on ...field.Expr) IUserDo
	Group(cols ...field.Expr) IUserDo
	Having(conds ...gen.Condition) IUserDo
	Limit(limit int) IUserDo
	Offset(offset int) IUserDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IUserDo
	Unscoped() IUserDo
	Create(values ...*model.User) error
	CreateInBatches(values []*model.User, batchSize int) error
	Save(values ...*model.User) error
	First() (*model.User, error)
	Take() (*model.User, error)
	Last() (*model.User, error)
	Find() ([]*model.User, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.User, err error)
	FindInBatches(result *[]*model.User, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.User) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IUserDo
	Assign(attrs ...field.AssignExpr) IUserDo
	Joins(fields ...field.RelationField) IUserDo
	Preload(fields ...field.RelationField) IUserDo
	FirstOrInit() (*model.User, error)
	FirstOrCreate() (*model.User, error)
	FindByPage(offset int, limit int) (result []*model.User, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IUserDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (u userDo) Debug() IUserDo {
	return u.withDO(u.DO.Debug())
}

func (u userDo) WithContext(ctx context.Context) IUserDo {
	return u.withDO(u.DO.WithContext(ctx))
}

func (u userDo) ReadDB() IUserDo {
	return u.Clauses(dbresolver.Read)
}

func (u userDo) WriteDB() IUserDo {
	return u.Clauses(dbresolver.Write)
}

func (u userDo) Session(config *gorm.Session) IUserDo {
	return u.withDO(u.DO.Session(config))
}

func (u userDo) Clauses(conds ...clause.Expression) IUserDo {
	return u.withDO(u.DO.Clauses(conds...))
}

func (u userDo) Returning(value interface{}, columns ...string) IUserDo {
	return u.withDO(u.DO.Returning(value, columns...))
}

func (u userDo) Not(conds ...gen.Condition) IUserDo {
	return u.withDO(u.DO.Not(conds...))
}

func (u userDo) Or(conds ...gen.Condition) IUserDo {
	return u.withDO(u.DO.Or(conds...))
}

func (u userDo) Select(conds ...field.Expr) IUserDo {
	return u.withDO(u.DO.Select(conds...))
}

func (u userDo) Where(conds ...gen.Condition) IUserDo {
	return u.withDO(u.DO.Where(conds...))
}

func (u userDo) Order(conds ...field.Expr) IUserDo {
	return u.withDO(u.DO.Order(conds...))
}

func (u userDo) Distinct(cols ...field.Expr) IUserDo {
	return u.withDO(u.DO.Distinct(cols...))
}

func (u userDo) Omit(cols ...field.Expr) IUserDo {
	return u.withDO(u.DO.Omit(cols...))
}

func (u userDo) Join(table schema.Tabler, on ...field.Expr) IUserDo {
	return u.withDO(u.DO.Join(table, on...))
}

func (u userDo) LeftJoin(table schema.Tabler, on ...field.Expr) IUserDo {
	return u.withDO(u.DO.LeftJoin(table, on...))
}

func (u userDo) RightJoin(table schema.Tabler, on ...field.Expr) IUserDo {
	return u.withDO(u.DO.RightJoin(table, on...))
}

func (u userDo) Group(cols ...field.Expr) IUserDo {
	return u.withDO(u.DO.Group(cols...))
}

func (u userDo) Having(conds ...gen.Condition) IUserDo {
	return u.withDO(u.DO.Having(conds...))
}

func (u userDo) Limit(limit int) IUserDo {
	return u.withDO(u.DO.Limit(limit))
}

func (u userDo) Offset(offset int) IUserDo {
	return u.withDO(u.DO.Offset(offset))
}

func (u userDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IUserDo {
	return u.withDO(u.DO.Scopes(funcs...))
}

func (u userDo) Unscoped() IUserDo {
	return u.withDO(u.DO.Unscoped())
}

func (u userDo) Create(values ...*model.User) error {
	if len(values) == 0 {
		return nil
	}
	return u.DO.Create(values)
}

func (u userDo) CreateInBatches(values []*model.User, batchSize int) error {
	return u.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (u userDo) Save(values ...*model.User) error {
	if len(values) == 0 {
		return nil
	}
	return u.DO.Save(values)
}

func (u userDo) First() (*model.User, error) {
	if result, err := u.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.User), nil
	}
}

func (u userDo) Take() (*model.User, error) {
	if result, err := u.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.User), nil
	}
}

func (u userDo) Last() (*model.User, error) {
	if result, err := u.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.User), nil
	}
}

func (u userDo) Find() ([]*model.User, error) {
	result, err := u.DO.Find()
	return result.([]*model.User), err
}

func (u userDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.User, err error) {
	buf := make([]*model.User, 0, batchSize)
	err = u.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (u userDo) FindInBatches(result *[]*model.User, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return u.DO.FindInBatches(result, batchSize, fc)
}

func (u userDo) Attrs(attrs ...field.AssignExpr) IUserDo {
	return u.withDO(u.DO.Attrs(attrs...))
}

func (u userDo) Assign(attrs ...field.AssignExpr) IUserDo {
	return u.withDO(u.DO.Assign(attrs...))
}

func (u userDo) Joins(fields ...field.RelationField) IUserDo {
	for _, _f := range fields {
		u = *u.withDO(u.DO.Joins(_f))
	}
	return &u
}

func (u userDo) Preload(fields ...field.RelationField) IUserDo {
	for _, _f := range fields {
		u = *u.withDO(u.DO.Preload(_f))
	}
	return &u
}

func (u userDo) FirstOrInit() (*model.User, error) {
	if result, err := u.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.User), nil
	}
}

func (u userDo) FirstOrCreate() (*model.User, error) {
	if result, err := u.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.User), nil
	}
}

func (u userDo) FindByPage(offset int, limit int) (result []*model.User, count int64, err error) {
	result, err = u.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = u.Offset(-1).Limit(-1).Count()
	return
}

func (u userDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = u.Count()
	if err != nil {
		return
	}

	err = u.Offset(offset).Limit(limit).Scan(result)
	return
}

func (u userDo) Scan(result interface{}) (err error) {
	return u.DO.Scan(result)
}

func (u userDo) Delete(models ...*model.User) (result gen.ResultInfo, err error) {
	return u.DO.Delete(models)
}

func (u *userDo) withDO(do gen.Dao) *userDo {
	u.DO = *do.(*gen.DO)
	return u
}
</file>

<file path="backend/internal/handler/disaster_handler.go">
package handler

import (
	"net/http"
	"time"

	"github.com/gin-gonic/gin"

	"github.com/AI1411/fullstack-react-go/internal/usecase"
)

type Disaster interface {
	ListDisasters(c *gin.Context)
}

type disasterHandler struct {
	disasterUseCase usecase.DisasterUseCase
}

func NewDisasterHandler(
	disasterUseCase usecase.DisasterUseCase,
) Disaster {
	return &disasterHandler{
		disasterUseCase: disasterUseCase,
	}
}

type ListDisastersResponse struct {
	ID                    string   `json:"id"`
	DisasterCode          string   `json:"disaster_code"`
	Name                  string   `json:"name"`
	PrefectureID          int32    `json:"prefecture_id"`
	OccurredAt            string   `json:"occurred_at"`
	Summary               string   `json:"summary"`
	DisasterType          string   `json:"disaster_type"`
	Status                string   `json:"status"`
	ImpactLevel           string   `json:"impact_level"`
	AffectedAreaSize      *float64 `json:"affected_area_size"`
	EstimatedDamageAmount *float64 `json:"estimated_damage_amount"`
}

// ListDisasters @title 災害マスタ一覧取得
// @id ListDisasters
// @tags disasters
// @accept json
// @produce json
// @version バージョン(1.0)
// @description
// @Summary 災害マスタ一覧取得
// @Success 200 {object} ListDisastersResponse
// @Router /disasters [get]
func (h *disasterHandler) ListDisasters(c *gin.Context) {
	disasters, err := h.disasterUseCase.ListDisasters(c.Request.Context())
	if err != nil {
		c.JSON(500, gin.H{"error": "Internal Server Error"})
		return
	}

	var response []*ListDisastersResponse
	for _, disaster := range disasters {
		response = append(response, &ListDisastersResponse{
			ID:                    disaster.ID,
			DisasterCode:          disaster.DisasterCode,
			Name:                  disaster.Name,
			PrefectureID:          disaster.PrefectureID,
			OccurredAt:            disaster.OccurredAt.Format(time.DateTime),
			Summary:               disaster.Summary,
			DisasterType:          disaster.DisasterType,
			Status:                disaster.Status,
			ImpactLevel:           disaster.ImpactLevel,
			AffectedAreaSize:      disaster.AffectedAreaSize,
			EstimatedDamageAmount: disaster.EstimatedDamageAmount,
		})
	}

	c.JSON(http.StatusOK, response)
}
</file>

<file path="backend/internal/infra/database/connection.go">
package database

import (
	"fmt"
	"os"

	"gorm.io/driver/postgres"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"
)

// NewDatabaseConnection はデータベース接続を確立し、接続オブジェクトを返します
func NewDatabaseConnection() (*gorm.DB, error) {
	// 環境変数からデータベース接続情報を取得
	dbHost := os.Getenv("DB_HOST")
	dbPort := os.Getenv("DB_PORT")
	dbUser := os.Getenv("DB_USER")
	dbPassword := os.Getenv("DB_PASSWORD")
	dbName := os.Getenv("DB_NAME")

	// PostgreSQL接続DSN
	dsn := fmt.Sprintf("host=%s port=%s user=%s password=%s dbname=%s sslmode=disable",
		dbHost, dbPort, dbUser, dbPassword, dbName)

	// GORMでデータベース接続（SQLログを表示）
	db, err := gorm.Open(postgres.Open(dsn), &gorm.Config{
		Logger: logger.Default.LogMode(logger.Info),
	})
	if err != nil {
		return nil, fmt.Errorf("データベース接続エラー: %w", err)
	}

	return db, nil
}
</file>

<file path="backend/internal/infra/datastore/disaster_repository.go">
package datastore

import (
	"context"

	"github.com/AI1411/fullstack-react-go/internal/domain/model"
	"github.com/AI1411/fullstack-react-go/internal/domain/query"
	"github.com/AI1411/fullstack-react-go/internal/infra/db"
)

type DisasterRepository interface {
	Find(ctx context.Context) ([]*model.Disaster, error)
}

type disasterRepository struct {
	client db.Client
	query  *query.Query
}

func NewDisasterRepository(
	ctx context.Context,
	client db.Client,
) DisasterRepository {
	return &disasterRepository{
		client: client,
		query:  query.Use(client.Conn(ctx)),
	}
}

func (r *disasterRepository) Find(ctx context.Context) ([]*model.Disaster, error) {
	disasters, err := r.query.Disaster.Find()
	if err != nil {
		return nil, err
	}

	return disasters, nil
}
</file>

<file path="backend/internal/middleware/cors.go">
package middleware

import (
	"time"

	"github.com/gin-contrib/cors"
	"github.com/gin-gonic/gin"
)

func CORSMiddleware() gin.HandlerFunc {
	config := cors.Config{
		AllowOrigins:     []string{"*"}, // TODO: change to specific domain
		AllowMethods:     []string{"GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS"},
		AllowHeaders:     []string{"Origin", "Content-Type", "Authorization", "X-Trace-ID"},
		ExposeHeaders:    []string{"Content-Length"},
		AllowCredentials: true,
		MaxAge:           12 * time.Hour,
	}

	return cors.New(config)
}
</file>

<file path="backend/internal/usecase/disacter_usecase.go">
package usecase

import (
	"context"

	"github.com/AI1411/fullstack-react-go/internal/domain/model"
	"github.com/AI1411/fullstack-react-go/internal/infra/datastore"
)

type DisasterUseCase interface {
	ListDisasters(ctx context.Context) ([]*model.Disaster, error)
}

type disasterUseCase struct {
	disasterRepository datastore.DisasterRepository
}

func NewDisasterUseCase(
	disasterRepository datastore.DisasterRepository,
) DisasterUseCase {
	return &disasterUseCase{
		disasterRepository: disasterRepository,
	}
}

func (u *disasterUseCase) ListDisasters(ctx context.Context) ([]*model.Disaster, error) {
	disasters, err := u.disasterRepository.Find(ctx)
	if err != nil {
		return nil, err
	}

	return disasters, nil
}
</file>

<file path="backend/.air.toml">
# Config file for [Air](https://github.com/cosmtrek/air) in TOML format

# Working directory
# . or absolute path, please note that the directories following must be under root.
root = "."
tmp_dir = "tmp"

[build]
# Just plain old shell command. You could use `make` as well.
cmd = "go build -o ./tmp/main ./cmd/api/main.go"
# Binary file yields from `cmd`.
bin = "tmp/main"
# Customize binary.
full_bin = "APP_ENV=dev APP_USER=air ./tmp/main"
# Watch these filename extensions.
include_ext = ["go", "tpl", "tmpl", "html"]
# Ignore these filename extensions or directories.
exclude_dir = ["assets", "tmp", "vendor", "frontend/node_modules"]
# Watch these directories if you specified.
include_dir = []
# Exclude files.
exclude_file = []
# Exclude specific regular expressions.
exclude_regex = ["_test.go"]
# Exclude unchanged files.
exclude_unchanged = true
# Follow symlink for directories
follow_symlink = true
# This log file places in your tmp_dir.
log = "air.log"
# It's not necessary to trigger docker each time file changes if it's too frequent.
delay = 1000 # ms
# Stop running old binary when docker errors occur.
stop_on_error = true
# Send Interrupt signal before killing process (windows does not support this feature)
send_interrupt = false
# Delay after sending Interrupt signal
kill_delay = 500 # ms

[log]
# Show log time
time = false

[color]
# Customize each part's color. If no color found, use the raw app log.
main = "magenta"
watcher = "cyan"
build = "yellow"
runner = "green"

[misc]
# Delete tmp directory on exit
clean_on_exit = true
</file>

<file path="backend/.editorconfig">
root = true

[*]
charset = utf-8
end_of_line = lf
insert_final_newline = true
trim_trailing_whitespace = true

[*.go]
indent_style = tab
indent_size = 4

[*.{json,yaml,yml}]
indent_style = space
indent_size = 2

[Makefile]
indent_style = tab
</file>

<file path="backend/.golangci.yml">
run:
  timeout: 5m
  modules-download-mode: readonly
  
linters:
  disable-all: true
  enable:
    # 基本的なエラーチェック
    - errcheck
    - gosimple
    - govet
    - ineffassign
    - staticcheck
    - typecheck
    - unused
    
    # コードスタイル
    - gofmt
    - gofumpt
    - goimports
    - gocritic
    - revive
    - stylecheck
    
    # 複雑度チェック
    - gocyclo
    - gocognit
    - funlen
    - lll
    
    # セキュリティ
    - gosec
    - exportloopref
    
    # パフォーマンス
    - prealloc
    - unconvert
    
    # 可読性
    - misspell
    - unparam
    - whitespace
    - wsl
    
    # テスト
    - testpackage
    - tparallel

linters-settings:
  # 行の長さ制限
  lll:
    line-length: 120
    
  # 関数の複雑度
  gocyclo:
    min-complexity: 15
    
  # 認知複雑度
  gocognit:
    min-complexity: 20
    
  # 関数の長さ
  funlen:
    lines: 80
    statements: 40
    
  # goimports設定
  goimports:
    local-prefixes: github.com/AI1411/fullstack-react-go
    
  # revive設定
  revive:
    confidence: 0.8
    rules:
      - name: exported
        severity: warning
        disabled: false
        arguments:
          - "checkPrivateReceivers"
          - "sayRepetitiveInsteadOfStutters"
      - name: package-comments
        severity: warning
        disabled: false
      - name: var-naming
        severity: warning
        disabled: false
        arguments:
          - ["ID"] # allow ID
          
  # gosec設定
  gosec:
    excludes:
      - G404 # 暗号学的に安全でない乱数の使用を除外（開発環境での使用）
      
  # gocritic設定
  gocritic:
    enabled-tags:
      - diagnostic
      - experimental
      - opinionated
      - performance
      - style
    disabled-checks:
      - dupImport # https://github.com/go-critic/go-critic/issues/845
      - ifElseChain
      - octalLiteral
      - whyNoLint

issues:
  # 新しいコードのみチェック
  new: false
  
  # 除外設定
  exclude-rules:
    # テストファイルでは一部のチェックを無効化
    - path: _test\.go
      linters:
        - gosec
        - dupl
        - funlen
        - gocyclo
        - gocognit
        
    # マイグレーションファイルでは一部のチェックを無効化
    - path: migrations/
      linters:
        - gofmt
        - goimports
        
    # 自動生成ファイルを除外
    - path: ".*\\.gen\\.go$"
      linters:
        - gosec
        - revive
        - stylecheck
        - unused
        
  # 除外する警告
  exclude:
    - "Error return value of .((os\\.)?std(out|err)\\..*|.*Close|.*Flush|os\\.Remove(All)?|.*printf?|os\\.(Un)?Setenv). is not checked"
</file>

<file path="backend/Dockerfile">
FROM golang:1.24.3-alpine AS builder

WORKDIR /app

COPY go.mod go.sum ./
RUN go mod download

COPY . .
RUN go build -o main ./cmd/api

FROM alpine:latest

WORKDIR /app

COPY --from=builder /app/main .

EXPOSE 8080

CMD ["./main"]
</file>

<file path="backend/README.md">
# 農地・農業用施設等災害復旧支援システム 機能要件定義書

## システム概要

自然災害による農地・農業用施設被害の拡大と地方公共団体の技術系職員減少に対応するための「災害事務ツール」。被害情報のデータベースによる一元管理、所定様式への自動反映、リモート査定の実現により、地方公共団体職員の業務効率化・迅速化を図る。

## 1. 基盤機能

### 1.1 認証・権限管理
- **ユーザー認証機能**
    - ログイン/ログアウト
    - 多要素認証（MFA）対応
    - パスワードポリシー設定
- **権限管理機能**
    - 役割ベースアクセス制御（RBAC）
    - 組織階層による権限設定
    - 機能別アクセス権限制御
- **ユーザー管理機能**
    - ユーザー登録・更新・削除
    - 組織情報管理
    - アクセス履歴管理

### 1.2 システム管理
- **マスタデータ管理**
    - 災害種別マスタ
    - 地域・行政区画マスタ
    - 施設種別マスタ
    - 被害程度マスタ
- **システム設定管理**
    - システムパラメータ設定
    - 帳票テンプレート管理
    - 通知設定管理
- **ログ・監査機能**
    - アクセスログ記録
    - 操作履歴記録
    - データ変更履歴管理

## 2. 被害情報管理機能

### 2.1 被害報告登録
- **基本情報登録**
    - 災害発生日時・場所
    - 災害種別（台風、洪水、地震等）
    - 報告者情報
    - 緊急度・優先度設定
- **被害詳細登録**
    - 被害箇所特定（GPS連携）
    - 被害状況詳細記述
    - 被害規模・範囲
    - 推定被害額
- **添付資料管理**
    - 写真・動画アップロード
    - ドキュメント添付
    - 図面・地図データ添付
    - ファイル形式チェック・容量制限

### 2.2 被害情報データベース
- **一元管理機能**
    - 全被害情報の統合管理
    - 重複チェック・統合機能
    - データ整合性確保
- **検索・絞り込み機能**
    - 条件別検索（地域、期間、被害種別等）
    - 全文検索機能
    - 地図ベース検索
- **データ連携機能**
    - 外部システムとのAPI連携
    - CSVインポート/エクスポート
    - 既存データベースとの連携

### 2.3 被害状況分析
- **統計分析機能**
    - 被害状況集計・分析
    - 地域別・時系列分析
    - 被害傾向分析
- **可視化機能**
    - ダッシュボード表示
    - グラフ・チャート生成
    - 地図上での被害分布表示
- **レポート機能**
    - 定型レポート自動生成
    - カスタムレポート作成
    - PDF/Excel出力

## 3. リモート査定機能

### 3.1 オンライン査定システム
- **ビデオ通話機能**
    - 高画質ビデオ会議
    - 画面共有機能
    - 録画・記録機能
- **リアルタイム協働機能**
    - 同時編集機能
    - チャット機能
    - ファイル共有機能
- **査定記録機能**
    - 査定内容記録
    - 査定結果保存
    - 査定履歴管理

### 3.2 ドローン・IoT連携
- **ドローン映像連携**
    - リアルタイム映像配信
    - 高解像度画像取得
    - 3Dマッピング連携
- **IoTセンサー連携**
    - 環境データ取得
    - 構造物監視データ
    - 気象データ連携
- **AI画像解析**
    - 被害程度自動判定
    - 異常検出機能
    - 測定・計算支援

### 3.3 査定結果管理
- **査定データ管理**
    - 査定結果記録・保存
    - 査定者情報管理
    - 査定基準管理
- **承認ワークフロー**
    - 段階的承認プロセス
    - 査定結果レビュー
    - 差戻し・修正機能
- **査定品質管理**
    - 査定精度管理
    - 査定者評価機能
    - 品質向上支援

## 4. 申請・手続き管理機能

### 4.1 申請書類作成
- **フォーム自動生成**
    - 災害種別別フォーム
    - 必須項目チェック
    - 入力支援機能
- **データ自動反映**
    - 被害情報からの自動入力
    - 関連データ自動取得
    - 計算式自動適用
- **書類テンプレート管理**
    - 申請書テンプレート
    - 様式バージョン管理
    - カスタマイズ機能

### 4.2 申請進捗管理
- **ワークフロー管理**
    - 申請プロセス定義
    - 承認フロー管理
    - 進捗状況追跡
- **期限管理機能**
    - 申請期限管理
    - リマインダー機能
    - 遅延アラート
- **コミュニケーション機能**
    - メッセージ機能
    - 通知機能
    - 問い合わせ管理

### 4.3 審査・承認機能
- **審査支援機能**
    - 審査チェックリスト
    - 自動審査項目
    - 審査履歴管理
- **承認管理機能**
    - 電子印鑑・署名
    - 承認権限管理
    - 承認履歴記録
- **差戻し・修正機能**
    - 差戻し理由記録
    - 修正指示機能
    - 再申請管理

## 5. 帳票・出力機能

### 5.1 定型帳票生成
- **災害復旧事業申請書**
    - 事業計画書自動生成
    - 被害状況調書作成
    - 工事費積算書生成
- **各種証明書**
    - 被害証明書発行
    - 査定証明書作成
    - 完了報告書生成
- **統計・分析帳票**
    - 被害状況一覧表
    - 地域別集計表
    - 月次・年次報告書

### 5.2 カスタム帳票
- **帳票デザイナー**
    - ドラッグ&ドロップ編集
    - テンプレート作成
    - プレビュー機能
- **データソース設定**
    - 複数データ源対応
    - 条件設定機能
    - 計算式設定
- **出力形式対応**
    - PDF/Excel/Word出力
    - 印刷設定管理
    - 電子署名対応

### 5.3 一括処理機能
- **バッチ処理**
    - 大量帳票一括生成
    - 定期自動生成
    - 処理状況監視
- **配布機能**
    - メール一括送信
    - ファイルサーバー配置
    - 印刷キュー管理

## 6. 地図・GIS機能

### 6.1 地図表示機能
- **ベースマップ**
    - 地理院地図連携
    - 航空写真表示
    - 地形図表示
- **レイヤー管理**
    - 被害情報レイヤー
    - 行政界レイヤー
    - インフラ情報レイヤー
- **地図操作機能**
    - ズーム・パン操作
    - 距離・面積測定
    - 座標取得機能

### 6.2 空間分析機能
- **被害分布分析**
    - 被害密度分析
    - クラスター分析
    - ホットスポット検出
- **影響範囲分析**
    - バッファ分析
    - 到達圏分析
    - 視界分析
- **地形分析**
    - 標高分析
    - 傾斜分析
    - 流域分析

### 6.3 災害対応支援
- **避難経路最適化**
    - 最短経路探索
    - 交通渋滞考慮
    - リアルタイム更新
- **リソース配置最適化**
    - 施設配置分析
    - アクセシビリティ分析
    - 需給バランス分析

## 7. 通知・コミュニケーション機能

### 7.1 通知システム
- **リアルタイム通知**
    - プッシュ通知
    - メール通知
    - SMS通知
- **通知管理**
    - 通知設定管理
    - 通知履歴管理
    - 通知テンプレート
- **緊急通知**
    - 緊急事態通知
    - 一斉通知機能
    - エスカレーション機能

### 7.2 情報共有機能
- **掲示板機能**
    - 情報共有掲示板
    - ファイル添付機能
    - コメント機能
- **FAQ管理**
    - よくある質問管理
    - 検索機能
    - カテゴリ管理
- **ナレッジベース**
    - 知識データベース
    - 事例集管理
    - ベストプラクティス共有

## 8. モバイル対応機能

### 8.1 現地調査支援
- **モバイルアプリ**
    - 現地調査アプリ
    - オフライン対応
    - データ同期機能
- **位置情報活用**
    - GPS連携
    - 位置情報記録
    - ジオフェンス機能
- **カメラ連携**
    - 写真撮影・アップロード
    - QRコード読取
    - 音声メモ機能

### 8.2 レスポンシブデザイン
- **マルチデバイス対応**
    - PC/タブレット/スマートフォン対応
    - 画面サイズ自動調整
    - タッチ操作最適化
- **ユーザビリティ**
    - 直感的UI/UX
    - アクセシビリティ対応
    - 操作ガイド機能

## 9. 外部連携機能

### 9.1 行政システム連携
- **既存システム連携**
    - 財務会計システム
    - 人事給与システム
    - 文書管理システム
- **標準API提供**
    - REST API
    - GraphQL API
    - Webhook機能
- **データ交換**
    - 標準フォーマット対応
    - バッチ連携
    - リアルタイム連携

### 9.2 外部サービス連携
- **気象情報連携**
    - 気象庁API連携
    - 気象警報取得
    - 予報データ活用
- **地図サービス連携**
    - Google Maps API
    - MapBox連携
    - OpenStreetMap活用
- **クラウドサービス連携**
    - AWS/Azure連携
    - ストレージ連携
    - AI/ML サービス活用

## 10. セキュリティ・運用機能

### 10.1 セキュリティ機能
- **データ暗号化**
    - 保存時暗号化
    - 通信時暗号化
    - 暗号化キー管理
- **アクセス制御**
    - IP制限機能
    - アクセス時間制限
    - 同時接続数制限
- **セキュリティ監視**
    - 不正アクセス検知
    - 異常行動検知
    - セキュリティログ管理

### 10.2 バックアップ・災害対策
- **データバックアップ**
    - 自動バックアップ
    - 世代管理
    - 遠隔地保存
- **災害対策**
    - DR（災害復旧）サイト
    - データ複製機能
    - 復旧手順書管理
- **可用性確保**
    - 冗長構成
    - 負荷分散
    - 監視・アラート

### 10.3 運用管理機能
- **システム監視**
    - リソース監視
    - パフォーマンス監視
    - 死活監視
- **メンテナンス機能**
    - 定期メンテナンス
    - アップデート管理
    - 障害対応機能
- **運用支援**
    - 運用手順書管理
    - 障害履歴管理
    - SLA管理

## 実装優先度

### フェーズ1（MVP）
1. 基盤機能（認証・権限管理）
2. 被害情報管理機能（基本）
3. 申請書類作成機能（基本）
4. 定型帳票生成機能

### フェーズ2
1. リモート査定機能（基本）
2. 地図・GIS機能（基本）
3. モバイル対応機能
4. 外部連携機能（基本）

### フェーズ3
1. AI画像解析機能
2. 高度な分析機能
3. IoT連携機能
4. セキュリティ強化機能
</file>

<file path="frontend/public/file.svg">
<svg fill="none" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.5 13.5V5.41a1 1 0 0 0-.3-.7L9.8.29A1 1 0 0 0 9.08 0H1.5v13.5A2.5 2.5 0 0 0 4 16h8a2.5 2.5 0 0 0 2.5-2.5m-1.5 0v-7H8v-5H3v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1M9.5 5V2.12L12.38 5zM5.13 5h-.62v1.25h2.12V5zm-.62 3h7.12v1.25H4.5zm.62 3h-.62v1.25h7.12V11z" clip-rule="evenodd" fill="#666" fill-rule="evenodd"/></svg>
</file>

<file path="frontend/public/globe.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.27 14.1a6.5 6.5 0 0 0 3.67-3.45q-1.24.21-2.7.34-.31 1.83-.97 3.1M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m.48-1.52a7 7 0 0 1-.96 0H7.5a4 4 0 0 1-.84-1.32q-.38-.89-.63-2.08a40 40 0 0 0 3.92 0q-.25 1.2-.63 2.08a4 4 0 0 1-.84 1.31zm2.94-4.76q1.66-.15 2.95-.43a7 7 0 0 0 0-2.58q-1.3-.27-2.95-.43a18 18 0 0 1 0 3.44m-1.27-3.54a17 17 0 0 1 0 3.64 39 39 0 0 1-4.3 0 17 17 0 0 1 0-3.64 39 39 0 0 1 4.3 0m1.1-1.17q1.45.13 2.69.34a6.5 6.5 0 0 0-3.67-3.44q.65 1.26.98 3.1M8.48 1.5l.01.02q.41.37.84 1.31.38.89.63 2.08a40 40 0 0 0-3.92 0q.25-1.2.63-2.08a4 4 0 0 1 .85-1.32 7 7 0 0 1 .96 0m-2.75.4a6.5 6.5 0 0 0-3.67 3.44 29 29 0 0 1 2.7-.34q.31-1.83.97-3.1M4.58 6.28q-1.66.16-2.95.43a7 7 0 0 0 0 2.58q1.3.27 2.95.43a18 18 0 0 1 0-3.44m.17 4.71q-1.45-.12-2.69-.34a6.5 6.5 0 0 0 3.67 3.44q-.65-1.27-.98-3.1" fill="#666"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h16v16H0z"/></clipPath></defs></svg>
</file>

<file path="frontend/public/next.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>
</file>

<file path="frontend/public/vercel.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1155 1000"><path d="m577.3 0 577.4 1000H0z" fill="#fff"/></svg>
</file>

<file path="frontend/public/window.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2.5h13v10a1 1 0 0 1-1 1h-11a1 1 0 0 1-1-1zM0 1h16v11.5a2.5 2.5 0 0 1-2.5 2.5h-11A2.5 2.5 0 0 1 0 12.5zm3.75 4.5a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5M7 4.75a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0m1.75.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5" fill="#666"/></svg>
</file>

<file path="frontend/src/app/application/new/page.tsx">
"use client"

import Footer from "@/components/layout/footer/page"
import Header from "@/components/layout/header/page"
import React, { useState } from "react"

const ReportGenerationPage: React.FC = () => {
  const [formData, setFormData] = useState({
    reportType: "",
    project: "",
    affectedArea: "",
    damageType: "",
    damageSeverity: "",
    reportDate: "",
    additionalNotes: "",
  })

  const handleSelectChange = (field: string, value: string) => {
    setFormData((prev) => ({
      ...prev,
      [field]: value,
    }))
  }

  const handleTextareaChange = (value: string) => {
    setFormData((prev) => ({
      ...prev,
      additionalNotes: value,
    }))
  }

  const handleGenerateReport = () => {
    console.log("Generating report with data:", formData)
    // ここにレポート生成のロジックを実装
  }

  return (
    <div
      className="relative flex size-full min-h-screen flex-col bg-white group/design-root overflow-x-hidden"
      style={
        {
          "--select-button-svg": `url('data:image/svg+xml,%3csvg xmlns=%27http://www.w3.org/2000/svg%27 width=%2724px%27 height=%2724px%27 fill=%27rgb(99,117,136)%27 viewBox=%270 0 256 256%27%3e%3cpath d=%27M181.66,170.34a8,8,0,0,1,0,11.32l-48,48a8,8,0,0,1-11.32,0l-48-48a8,8,0,0,1,11.32-11.32L128,212.69l42.34-42.35A8,8,0,0,1,181.66,170.34Zm-96-84.68L128,43.31l42.34,42.35a8,8,0,0,0,11.32-11.32l-48-48a8,8,0,0,0-11.32,0l-48,48A8,8,0,0,0,85.66,85.66Z%27%3e%3c/path%3e%3c/svg%3e')`,
          fontFamily: '"Public Sans", "Noto Sans", sans-serif',
        } as React.CSSProperties
      }
    >
      <div className="layout-container flex h-full grow flex-col">
        <Header />

        <div className="px-40 flex flex-1 justify-center py-5">
          <div className="layout-content-container flex flex-col max-w-[960px] flex-1">
            <div className="flex flex-wrap justify-between gap-3 p-4">
              <p className="text-[#111418] tracking-light text-[32px] font-bold leading-tight min-w-72">
                レポート生成
              </p>
            </div>

            <div className="flex max-w-[480px] flex-wrap items-end gap-4 px-4 py-3">
              <label className="flex flex-col min-w-40 flex-1">
                <p className="text-[#111418] text-base font-medium leading-normal pb-2">
                  レポート種別
                </p>
                <select
                  value={formData.reportType}
                  onChange={(e) =>
                    handleSelectChange("reportType", e.target.value)
                  }
                  className="form-input flex w-full min-w-0 flex-1 resize-none overflow-hidden rounded-lg text-[#111418] focus:outline-0 focus:ring-0 border border-[#dce0e5] bg-white focus:border-[#dce0e5] h-14 bg-[image:--select-button-svg] placeholder:text-[#637588] p-[15px] text-base font-normal leading-normal"
                >
                  <option value="">選択してください</option>
                  <option value="damage-assessment">被害査定レポート</option>
                  <option value="recovery-plan">復旧計画レポート</option>
                  <option value="financial-impact">経済影響レポート</option>
                </select>
              </label>
            </div>

            <div className="flex max-w-[480px] flex-wrap items-end gap-4 px-4 py-3">
              <label className="flex flex-col min-w-40 flex-1">
                <p className="text-[#111418] text-base font-medium leading-normal pb-2">
                  プロジェクト
                </p>
                <select
                  value={formData.project}
                  onChange={(e) =>
                    handleSelectChange("project", e.target.value)
                  }
                  className="form-input flex w-full min-w-0 flex-1 resize-none overflow-hidden rounded-lg text-[#111418] focus:outline-0 focus:ring-0 border border-[#dce0e5] bg-white focus:border-[#dce0e5] h-14 bg-[image:--select-button-svg] placeholder:text-[#637588] p-[15px] text-base font-normal leading-normal"
                >
                  <option value="">選択してください</option>
                  <option value="project-001">
                    プロジェクト001 - 台風被害対応
                  </option>
                  <option value="project-002">
                    プロジェクト002 - 水害復旧
                  </option>
                  <option value="project-003">
                    プロジェクト003 - 干ばつ対策
                  </option>
                </select>
              </label>
            </div>

            <div className="flex max-w-[480px] flex-wrap items-end gap-4 px-4 py-3">
              <label className="flex flex-col min-w-40 flex-1">
                <p className="text-[#111418] text-base font-medium leading-normal pb-2">
                  被災地域
                </p>
                <select
                  value={formData.affectedArea}
                  onChange={(e) =>
                    handleSelectChange("affectedArea", e.target.value)
                  }
                  className="form-input flex w-full min-w-0 flex-1 resize-none overflow-hidden rounded-lg text-[#111418] focus:outline-0 focus:ring-0 border border-[#dce0e5] bg-white focus:border-[#dce0e5] h-14 bg-[image:--select-button-svg] placeholder:text-[#637588] p-[15px] text-base font-normal leading-normal"
                >
                  <option value="">選択してください</option>
                  <option value="kyoto">京都府</option>
                  <option value="osaka">大阪府</option>
                  <option value="hyogo">兵庫県</option>
                  <option value="nara">奈良県</option>
                  <option value="shiga">滋賀県</option>
                  <option value="wakayama">和歌山県</option>
                </select>
              </label>
            </div>

            <div className="flex max-w-[480px] flex-wrap items-end gap-4 px-4 py-3">
              <label className="flex flex-col min-w-40 flex-1">
                <p className="text-[#111418] text-base font-medium leading-normal pb-2">
                  被害種別
                </p>
                <select
                  value={formData.damageType}
                  onChange={(e) =>
                    handleSelectChange("damageType", e.target.value)
                  }
                  className="form-input flex w-full min-w-0 flex-1 resize-none overflow-hidden rounded-lg text-[#111418] focus:outline-0 focus:ring-0 border border-[#dce0e5] bg-white focus:border-[#dce0e5] h-14 bg-[image:--select-button-svg] placeholder:text-[#637588] p-[15px] text-base font-normal leading-normal"
                >
                  <option value="">選択してください</option>
                  <option value="flood">洪水</option>
                  <option value="typhoon">台風</option>
                  <option value="hail">雹害</option>
                  <option value="drought">干ばつ</option>
                  <option value="landslide">地滑り</option>
                  <option value="strong-wind">強風</option>
                </select>
              </label>
            </div>

            <div className="flex max-w-[480px] flex-wrap items-end gap-4 px-4 py-3">
              <label className="flex flex-col min-w-40 flex-1">
                <p className="text-[#111418] text-base font-medium leading-normal pb-2">
                  被害程度
                </p>
                <select
                  value={formData.damageSeverity}
                  onChange={(e) =>
                    handleSelectChange("damageSeverity", e.target.value)
                  }
                  className="form-input flex w-full min-w-0 flex-1 resize-none overflow-hidden rounded-lg text-[#111418] focus:outline-0 focus:ring-0 border border-[#dce0e5] bg-white focus:border-[#dce0e5] h-14 bg-[image:--select-button-svg] placeholder:text-[#637588] p-[15px] text-base font-normal leading-normal"
                >
                  <option value="">選択してください</option>
                  <option value="minor">軽微</option>
                  <option value="moderate">中程度</option>
                  <option value="severe">深刻</option>
                  <option value="critical">甚大</option>
                </select>
              </label>
            </div>

            <div className="flex max-w-[480px] flex-wrap items-end gap-4 px-4 py-3">
              <label className="flex flex-col min-w-40 flex-1">
                <p className="text-[#111418] text-base font-medium leading-normal pb-2">
                  レポート日付
                </p>
                <select
                  value={formData.reportDate}
                  onChange={(e) =>
                    handleSelectChange("reportDate", e.target.value)
                  }
                  className="form-input flex w-full min-w-0 flex-1 resize-none overflow-hidden rounded-lg text-[#111418] focus:outline-0 focus:ring-0 border border-[#dce0e5] bg-white focus:border-[#dce0e5] h-14 bg-[image:--select-button-svg] placeholder:text-[#637588] p-[15px] text-base font-normal leading-normal"
                >
                  <option value="">選択してください</option>
                  <option value="2024-12-01">2024年12月1日</option>
                  <option value="2024-11-30">2024年11月30日</option>
                  <option value="2024-11-29">2024年11月29日</option>
                  <option value="custom">カスタム日付</option>
                </select>
              </label>
            </div>

            <div className="flex max-w-[480px] flex-wrap items-end gap-4 px-4 py-3">
              <label className="flex flex-col min-w-40 flex-1">
                <p className="text-[#111418] text-base font-medium leading-normal pb-2">
                  追加メモ
                </p>
                <textarea
                  placeholder="追加のメモや観察事項を入力してください"
                  value={formData.additionalNotes}
                  onChange={(e) => handleTextareaChange(e.target.value)}
                  className="form-input flex w-full min-w-0 flex-1 resize-none overflow-hidden rounded-lg text-[#111418] focus:outline-0 focus:ring-0 border border-[#dce0e5] bg-white focus:border-[#dce0e5] min-h-36 placeholder:text-[#637588] p-[15px] text-base font-normal leading-normal"
                />
              </label>
            </div>

            <div className="flex px-4 py-3 justify-end">
              <button
                onClick={handleGenerateReport}
                className="flex min-w-[84px] max-w-[480px] cursor-pointer items-center justify-center overflow-hidden rounded-lg h-12 px-5 bg-[#197fe5] text-white text-base font-bold leading-normal tracking-[0.015em] hover:bg-[#1565c0] transition-colors"
              >
                <span className="truncate">レポート生成</span>
              </button>
            </div>
          </div>
        </div>

        <Footer />
      </div>
    </div>
  )
}

export default ReportGenerationPage
</file>

<file path="frontend/src/app/application/page.tsx">
"use client"

import Footer from "@/components/layout/footer/page"
import Header from "@/components/layout/header/page"
import Link from "next/link"

// サンプルデータ (実際にはAPIなどから取得します)
const applicationData = [
  {
    id: "A001",
    date: "2024-07-18",
    applicant: "山田農園",
    disasterName: "京都府洪水被害",
    disasterId: "1",
    requestAmount: "2,500,000円",
    status: "審査中",
    category: "施設復旧",
  },
  {
    id: "A002",
    date: "2024-07-16",
    applicant: "大阪みかん生産組合",
    disasterName: "大阪府地滑り被害",
    disasterId: "2",
    requestAmount: "1,800,000円",
    status: "書類確認中",
    category: "機械購入",
  },
  {
    id: "A003",
    date: "2024-07-12",
    applicant: "兵庫果樹園",
    disasterName: "兵庫県雹害",
    disasterId: "3",
    requestAmount: "3,200,000円",
    status: "承認済",
    category: "農地復旧",
  },
  {
    id: "A004",
    date: "2024-07-10",
    applicant: "奈良田んぼ組合",
    disasterName: "奈良県干ばつ被害",
    disasterId: "4",
    requestAmount: "1,500,000円",
    status: "審査中",
    category: "水利施設",
  },
  {
    id: "A005",
    date: "2024-07-05",
    applicant: "滋賀グリーンハウス",
    disasterName: "滋賀県風害",
    disasterId: "5",
    requestAmount: "4,200,000円",
    status: "支払処理中",
    category: "施設復旧",
  },
  {
    id: "A006",
    date: "2024-07-01",
    applicant: "和歌山みかん農園",
    disasterName: "和歌山県水害",
    disasterId: "6",
    requestAmount: "1,700,000円",
    status: "完了",
    category: "農地復旧",
  },
  {
    id: "A007",
    date: "2024-06-28",
    applicant: "三重農業協同組合",
    disasterName: "三重県地滑り被害",
    disasterId: "7",
    requestAmount: "2,900,000円",
    status: "審査中",
    category: "道路復旧",
  },
  {
    id: "A008",
    date: "2024-06-22",
    applicant: "愛知野菜生産者",
    disasterName: "愛知県雹害",
    disasterId: "8",
    requestAmount: "1,200,000円",
    status: "書類確認中",
    category: "農地復旧",
  },
  {
    id: "A009",
    date: "2024-06-18",
    applicant: "岐阜畜産農家",
    disasterName: "岐阜県干ばつ被害",
    disasterId: "9",
    requestAmount: "3,500,000円",
    status: "完了",
    category: "給水設備",
  },
  {
    id: "A010",
    date: "2024-06-15",
    applicant: "静岡果樹園",
    disasterName: "静岡県風害",
    disasterId: "10",
    requestAmount: "1,900,000円",
    status: "承認済",
    category: "農地復旧",
  },
]

// ステータスに応じたバッジの色を定義
const getStatusBadgeClass = (status: string) => {
  switch (status) {
    case "審査中":
      return "bg-[#f0f2f4] text-[#111418]"
    case "書類確認中":
      return "bg-[#edf5ff] text-[#0055cc]"
    case "承認済":
      return "bg-[#e3fcef] text-[#006644]"
    case "支払処理中":
      return "bg-[#fff7e6] text-[#ff8b00]"
    case "完了":
      return "bg-[#e6fcf5] text-[#00a3bf]"
    default:
      return "bg-[#f0f2f4] text-[#111418]"
  }
}

export default function ApplicationPage() {
  return (
    <div className="layout-container flex h-full grow flex-col">
      <Header />
      <main className="px-40 flex flex-1 justify-center py-5">
        <div className="layout-content-container flex flex-col max-w-[960px] flex-1">
          <div className="flex flex-wrap justify-between gap-3 p-4">
            <div className="flex min-w-72 flex-col gap-3">
              <p className="text-[#111418] tracking-light text-[32px] font-bold leading-tight">
                支援申請一覧
              </p>
              <p className="text-[#637588] text-sm font-normal leading-normal">
                農業災害に関する支援申請の一覧です。申請者、申請日、申請金額、状況などの情報を確認できます。
              </p>
            </div>
            <div className="flex items-end">
              <Link
                href="/application/new"
                className="flex cursor-pointer items-center justify-center overflow-hidden rounded-lg h-10 px-4 bg-[#111418] text-white gap-2 text-sm font-bold leading-normal tracking-[0.015em]"
              >
                <span>新規申請</span>
              </Link>
            </div>
          </div>
          <div className="px-4 py-3 @container">
            <div className="flex overflow-hidden rounded-lg border border-[#dce0e5] bg-white">
              <table className="flex-1">
                <thead>
                  <tr className="bg-white">
                    <th className="table-column-120 px-4 py-3 text-left text-[#111418] w-[120px] text-sm font-medium leading-normal">
                      申請ID
                    </th>
                    <th className="table-column-240 px-4 py-3 text-left text-[#111418] w-[120px] text-sm font-medium leading-normal">
                      申請日
                    </th>
                    <th className="table-column-360 px-4 py-3 text-left text-[#111418] w-[150px] text-sm font-medium leading-normal">
                      申請者
                    </th>
                    <th className="table-column-480 px-4 py-3 text-left text-[#111418] w-[150px] text-sm font-medium leading-normal">
                      災害名
                    </th>
                    <th className="table-column-600 px-4 py-3 text-left text-[#111418] w-[120px] text-sm font-medium leading-normal">
                      申請金額
                    </th>
                    <th className="table-column-720 px-4 py-3 text-left text-[#111418] w-[100px] text-sm font-medium leading-normal">
                      ステータス
                    </th>
                    <th className="table-column-840 px-4 py-3 text-left text-[#111418] w-[100px] text-[#637588] text-sm font-medium leading-normal">
                      アクション
                    </th>
                  </tr>
                </thead>
                <tbody>
                  {applicationData.map((item) => (
                    <tr key={item.id} className="border-t border-t-[#dce0e5]">
                      <td className="table-column-120 h-[72px] px-4 py-2 w-[120px] text-[#637588] text-sm font-normal leading-normal">
                        {item.id}
                      </td>
                      <td className="table-column-240 h-[72px] px-4 py-2 w-[120px] text-[#637588] text-sm font-normal leading-normal">
                        {item.date}
                      </td>
                      <td className="table-column-360 h-[72px] px-4 py-2 w-[150px] text-[#637588] text-sm font-normal leading-normal">
                        {item.applicant}
                      </td>
                      <td className="table-column-480 h-[72px] px-4 py-2 w-[150px] text-[#637588] text-sm font-normal leading-normal">
                        <Link
                          href={`/disasters/${item.disasterId}`}
                          className="text-[#007bff] hover:underline"
                        >
                          {item.disasterName}
                        </Link>
                      </td>
                      <td className="table-column-600 h-[72px] px-4 py-2 w-[120px] text-[#637588] text-sm font-normal leading-normal">
                        {item.requestAmount}
                      </td>
                      <td className="table-column-720 h-[72px] px-4 py-2 w-[100px] text-sm font-normal leading-normal">
                        <button
                          className={`flex min-w-[84px] max-w-[480px] cursor-pointer items-center justify-center overflow-hidden rounded-lg h-8 px-3 ${getStatusBadgeClass(
                            item.status
                          )} text-sm font-medium leading-normal w-full`}
                        >
                          <span className="truncate">{item.status}</span>
                        </button>
                      </td>
                      <td className="table-column-840 h-[72px] px-4 py-2 w-[100px] text-sm font-bold leading-normal tracking-[0.015em]">
                        <Link
                          href={`/application/${item.id}`}
                          className="text-[#007bff] hover:underline"
                        >
                          詳細を表示
                        </Link>
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          </div>
        </div>
      </main>
      <Footer />
    </div>
  )
}
</file>

<file path="frontend/src/app/globals.css">
@import "tailwindcss";
@import "tw-animate-css";

@custom-variant dark (&:is(.dark *));

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
  --color-sidebar-ring: var(--sidebar-ring);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar: var(--sidebar);
  --color-chart-5: var(--chart-5);
  --color-chart-4: var(--chart-4);
  --color-chart-3: var(--chart-3);
  --color-chart-2: var(--chart-2);
  --color-chart-1: var(--chart-1);
  --color-ring: var(--ring);
  --color-input: var(--input);
  --color-border: var(--border);
  --color-destructive: var(--destructive);
  --color-accent-foreground: var(--accent-foreground);
  --color-accent: var(--accent);
  --color-muted-foreground: var(--muted-foreground);
  --color-muted: var(--muted);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-secondary: var(--secondary);
  --color-primary-foreground: var(--primary-foreground);
  --color-primary: var(--primary);
  --color-popover-foreground: var(--popover-foreground);
  --color-popover: var(--popover);
  --color-card-foreground: var(--card-foreground);
  --color-card: var(--card);
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
}

:root {
  --radius: 0.625rem;
  --background: oklch(1 0 0);
  --foreground: oklch(0.145 0 0);
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.145 0 0);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.145 0 0);
  --primary: oklch(0.205 0 0);
  --primary-foreground: oklch(0.985 0 0);
  --secondary: oklch(0.97 0 0);
  --secondary-foreground: oklch(0.205 0 0);
  --muted: oklch(0.97 0 0);
  --muted-foreground: oklch(0.556 0 0);
  --accent: oklch(0.97 0 0);
  --accent-foreground: oklch(0.205 0 0);
  --destructive: oklch(0.577 0.245 27.325);
  --border: oklch(0.922 0 0);
  --input: oklch(0.922 0 0);
  --ring: oklch(0.708 0 0);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --sidebar: oklch(0.985 0 0);
  --sidebar-foreground: oklch(0.145 0 0);
  --sidebar-primary: oklch(0.205 0 0);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.97 0 0);
  --sidebar-accent-foreground: oklch(0.205 0 0);
  --sidebar-border: oklch(0.922 0 0);
  --sidebar-ring: oklch(0.708 0 0);
}

.dark {
  --background: oklch(0.145 0 0);
  --foreground: oklch(0.985 0 0);
  --card: oklch(0.205 0 0);
  --card-foreground: oklch(0.985 0 0);
  --popover: oklch(0.205 0 0);
  --popover-foreground: oklch(0.985 0 0);
  --primary: oklch(0.922 0 0);
  --primary-foreground: oklch(0.205 0 0);
  --secondary: oklch(0.269 0 0);
  --secondary-foreground: oklch(0.985 0 0);
  --muted: oklch(0.269 0 0);
  --muted-foreground: oklch(0.708 0 0);
  --accent: oklch(0.269 0 0);
  --accent-foreground: oklch(0.985 0 0);
  --destructive: oklch(0.704 0.191 22.216);
  --border: oklch(1 0 0 / 10%);
  --input: oklch(1 0 0 / 15%);
  --ring: oklch(0.556 0 0);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.205 0 0);
  --sidebar-foreground: oklch(0.985 0 0);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.269 0 0);
  --sidebar-accent-foreground: oklch(0.985 0 0);
  --sidebar-border: oklch(1 0 0 / 10%);
  --sidebar-ring: oklch(0.556 0 0);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}
</file>

<file path="frontend/src/components/ui/button.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }
</file>

<file path="frontend/src/lib/utils.ts">
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
</file>

<file path="frontend/.gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
</file>

<file path="frontend/biome.json">
{
	"$schema": "https://biomejs.dev/schemas/1.9.4/schema.json",
	"vcs": {
		"enabled": false,
		"clientKind": "git",
		"useIgnoreFile": false
	},
	"files": {
		"ignoreUnknown": false,
		"ignore": []
	},
	"formatter": {
		"enabled": true,
		"indentStyle": "space"
	},
	"organizeImports": {
		"enabled": true
	},
	"linter": {
		"enabled": true,
		"rules": {
			"style": {
				"useImportType": "off",
				"useExportType": "off"
			},
			"recommended": true
		}
	},
	"javascript": {
		"formatter": {
			"quoteStyle": "double",
			"semicolons": "asNeeded",
			"trailingCommas": "es5"
		}
	}
}
</file>

<file path="frontend/components.json">
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "src/app/globals.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}
</file>

<file path="frontend/next.config.ts">
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;
</file>

<file path="frontend/postcss.config.mjs">
const config = {
  plugins: ["@tailwindcss/postcss"],
};

export default config;
</file>

<file path="frontend/README.md">
This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.
</file>

<file path="frontend/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
</file>

<file path="backend/cmd/gormgen/generate_all/main.go">
package main

import (
	"context"

	"gorm.io/gen"

	"github.com/AI1411/fullstack-react-go/internal/infra/db"
	applogger "github.com/AI1411/fullstack-react-go/internal/infra/logger"
)

func main() {
	ctx := context.Background()

	g := gen.NewGenerator(gen.Config{
		OutPath:           "./internal/domain/query", // 出力パス
		Mode:              gen.WithoutContext | gen.WithDefaultQuery | gen.WithQueryInterface,
		FieldWithIndexTag: true,
		FieldWithTypeTag:  true,
		FieldNullable:     true,
	})

	sqlHandler, err := db.NewSqlHandler(
		db.DefaultDatabaseConfig(),
		applogger.New(applogger.DefaultConfig()),
	)
	if err != nil {
		panic(err)
	}

	g.UseDB(sqlHandler.Conn(ctx))

	// schema_migrationsを除外してテーブル生成
	tables, err := sqlHandler.Conn(ctx).Migrator().GetTables()
	if err != nil {
		panic(err)
	}

	// schema_migrationsを除外
	var filteredTables []interface{}

	for _, tableName := range tables {
		if tableName != "schema_migrations" {
			model := g.GenerateModel(tableName)
			filteredTables = append(filteredTables, model)
		}
	}

	g.ApplyBasic(filteredTables...)

	// Generate the code
	g.Execute()
}
</file>

<file path="backend/internal/env/env.go">
package env

import (
	"fmt"
	"time"

	"github.com/kelseyhightower/envconfig"
	"github.com/pkg/errors"
)

type Values struct {
	DB
	Env        string `default:"local" split_words:"true"`
	ServerPort string `required:"true" split_words:"true"`
}

type DB struct {
	DatabaseHost          string        `required:"true" split_words:"true"`
	DatabaseUsername      string        `required:"true" split_words:"true"`
	DatabasePassword      string        `required:"true" split_words:"true"`
	DatabaseName          string        `required:"true" split_words:"true"`
	DatabasePort          string        `default:"3306" split_words:"true"`
	ConnectionMaxOpen     int           `default:"10" split_words:"true"`
	ConnectionMaxIdle     int           `default:"2" split_words:"true"`
	ConnectionMaxLifetime time.Duration `default:"300s" split_words:"true"`
}

func NewValues() (*Values, error) {
	var v Values

	err := envconfig.Process("", &v)
	if err != nil {
		s := fmt.Sprintf("need to set all env values %+v", v)
		return nil, errors.Wrap(err, s)
	}

	return &v, nil
}

func (v Values) IsLocal() bool {
	return v.Env == "local" || v.Env == "test"
}
</file>

<file path="backend/internal/infra/logger/logger.go">
// Package logger provides a centralized way to configure and use slog throughout the application.
package logger

import (
	"context"
	"io"
	"log/slog"
	"os"
	"time"
)

// LogLevel represents the logging level.
type LogLevel string

const (
	// DebugLevel logs debug messages.
	DebugLevel LogLevel = "debug"
	// InfoLevel logs informational messages.
	InfoLevel LogLevel = "info"
	// WarnLevel logs warning messages.
	WarnLevel LogLevel = "warn"
	// ErrorLevel logs error messages.
	ErrorLevel LogLevel = "error"
)

// Logger is a wrapper around slog.Logger that provides additional functionality.
type Logger struct {
	*slog.Logger
}

// Config holds the configuration for the logger.
type Config struct {
	// Level is the minimum log level that will be logged.
	Level LogLevel
	// Output is where the logs will be written to.
	Output io.Writer
	// AddSource adds the source file and line number to the log.
	AddSource bool
	// JSON determines whether the logs should be formatted as JSON.
	JSON bool
}

// DefaultConfig returns a default configuration for the logger.
func DefaultConfig() Config {
	return Config{
		Level:     InfoLevel,
		Output:    os.Stdout,
		AddSource: true,
		JSON:      true,
	}
}

// New creates a new Logger with the given configuration.
func New(cfg Config) *Logger {
	var level slog.Level

	switch cfg.Level {
	case DebugLevel:
		level = slog.LevelDebug
	case InfoLevel:
		level = slog.LevelInfo
	case WarnLevel:
		level = slog.LevelWarn
	case ErrorLevel:
		level = slog.LevelError
	default:
		level = slog.LevelInfo
	}

	var handler slog.Handler

	opts := &slog.HandlerOptions{
		Level:     level,
		AddSource: cfg.AddSource,
	}

	if cfg.JSON {
		handler = slog.NewJSONHandler(cfg.Output, opts)
	} else {
		handler = slog.NewTextHandler(cfg.Output, opts)
	}

	return &Logger{
		Logger: slog.New(handler),
	}
}

// With returns a new Logger with the given attributes added to the context.
func (l *Logger) With(args ...any) *Logger {
	return &Logger{
		Logger: l.Logger.With(args...),
	}
}

// WithContext returns a new context with the logger attached.
func (l *Logger) WithContext(ctx context.Context) context.Context {
	return context.WithValue(ctx, loggerKey{}, l)
}

// FromContext returns the logger from the context.
// If no logger is found, it returns a default logger.
func FromContext(ctx context.Context) *Logger {
	if logger, ok := ctx.Value(loggerKey{}).(*Logger); ok {
		return logger
	}

	return &Logger{
		Logger: slog.Default(),
	}
}

// loggerKey is the key used to store the logger in the context.
type loggerKey struct{}

// LogRequest logs information about an HTTP request.
func (l *Logger) LogRequest(method, path string, statusCode int, latency time.Duration) {
	l.Info("request",
		slog.String("method", method),
		slog.String("path", path),
		slog.Int("status", statusCode),
		slog.Duration("latency", latency),
	)
}

// LogError logs an error with additional context.
func (l *Logger) LogError(err error, msg string, args ...any) {
	if err != nil {
		l.Error(msg, append(args, slog.Any("error", err))...)
	}
}
</file>

<file path="backend/internal/middleware/logging.go">
package middleware

import (
	"bytes"
	"context"
	"encoding/json"
	"io"
	"log/slog"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"

	"github.com/AI1411/fullstack-react-go/internal/infra/logger"
)

type responseWriter struct {
	gin.ResponseWriter
	body *bytes.Buffer
}

func (w responseWriter) Write(b []byte) (int, error) {
	w.body.Write(b)
	return w.ResponseWriter.Write(b)
}

func NewLogging(logger *logger.Logger) gin.HandlerFunc {
	return func(c *gin.Context) {
		endpoint := c.Request.RequestURI
		if endpoint == "/metrics" {
			c.Next()
			return
		}

		var traceID string
		traceID = c.GetHeader("X-Trace-ID")

		if traceID == "" {
			traceID = getTraceID(c.Request.Context())
		}

		ctx := context.WithValue(c.Request.Context(), "trace_id", traceID)
		c.Request = c.Request.WithContext(ctx)

		c.Set("trace_id", traceID)
		bufBody, _ := io.ReadAll(c.Request.Body)
		reqBody := map[string]any{}
		_ = json.Unmarshal(bufBody, &reqBody)

		c.Request.Body = io.NopCloser(bytes.NewBuffer(bufBody))

		logger.Info("request",
			slog.String("trace_id", traceID),
			slog.String("http_method", c.Request.Method),
			slog.String("endpoint", endpoint),
			slog.Any("header", c.Request.Header),
			slog.Any("body", reqBody),
		)

		writer := &responseWriter{
			ResponseWriter: c.Writer,
			body:           bytes.NewBufferString(""),
		}
		c.Writer = writer

		defer func() {
			logger.Info("response",
				slog.String("trace_id", traceID),
				slog.String("endpoint", endpoint),
				slog.Any("header", writer.Header()),
				slog.Int("http_status", writer.Status()),
				slog.Any("body", writer.body.String()),
			)
		}()

		c.Next()
	}
}

func getTraceID(ctx context.Context) string {
	traceID, ok := ctx.Value("trace_id").(string)
	if !ok {
		tid, _ := uuid.NewRandom()
		traceID = tid.String()

		return traceID
	}

	return traceID
}
</file>

<file path="backend/migrations/000002_create_prefectures_and_regions_tables.up.sql">
-- 地域マスタテーブル
DROP TABLE IF EXISTS regions CASCADE;
CREATE TABLE IF NOT EXISTS regions
(
    id   SERIAL PRIMARY KEY,
    name VARCHAR(50) NOT NULL UNIQUE
);

CREATE INDEX IF NOT EXISTS idx_regions_name ON regions (name);

COMMENT ON TABLE regions IS '地域マスタテーブル';
COMMENT ON COLUMN regions.id IS '地域ID';
COMMENT ON COLUMN regions.name IS '地域名';
-- 都道府県と地域の初期データを挿入
INSERT INTO regions (name)
VALUES ('北海道・東北'),
       ('関東'),
       ('中部'),
       ('近畿'),
       ('中国'),
       ('四国'),
       ('九州・沖縄');

-- 都道府県マスタテーブル
DROP TABLE IF EXISTS prefectures CASCADE;
CREATE TABLE IF NOT EXISTS prefectures
(
    id        SERIAL PRIMARY KEY,
    name      VARCHAR(10) NOT NULL UNIQUE,
    region_id INT         NOT NULL REFERENCES regions (id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_prefectures_name ON prefectures (name);
CREATE INDEX IF NOT EXISTS idx_prefectures_region_id ON prefectures (region_id);
COMMENT ON COLUMN prefectures.id IS '都道府県名';
COMMENT ON COLUMN prefectures.name IS '都道府県名';
COMMENT ON COLUMN prefectures.region_id IS '地域ID';

-- 都道府県マスタデータのINSERT
-- region_id: 1=北海道・東北, 2=関東, 3=中部, 4=近畿, 5=中国, 6=四国, 7=九州・沖縄

INSERT INTO prefectures (name, region_id)
VALUES
-- 北海道・東北地方 (region_id: 1)
('北海道', 1),
('青森県', 1),
('岩手県', 1),
('宮城県', 1),
('秋田県', 1),
('山形県', 1),
('福島県', 1),

-- 関東地方 (region_id: 2)
('茨城県', 2),
('栃木県', 2),
('群馬県', 2),
('埼玉県', 2),
('千葉県', 2),
('東京都', 2),
('神奈川県', 2),

-- 中部地方 (region_id: 3)
('新潟県', 3),
('富山県', 3),
('石川県', 3),
('福井県', 3),
('山梨県', 3),
('長野県', 3),
('岐阜県', 3),
('静岡県', 3),
('愛知県', 3),

-- 近畿地方 (region_id: 4)
('三重県', 4),
('滋賀県', 4),
('京都府', 4),
('大阪府', 4),
('兵庫県', 4),
('奈良県', 4),
('和歌山県', 4),

-- 中国地方 (region_id: 5)
('鳥取県', 5),
('島根県', 5),
('岡山県', 5),
('広島県', 5),
('山口県', 5),

-- 四国地方 (region_id: 6)
('徳島県', 6),
('香川県', 6),
('愛媛県', 6),
('高知県', 6),

-- 九州・沖縄地方 (region_id: 7)
('福岡県', 7),
('佐賀県', 7),
('長崎県', 7),
('熊本県', 7),
('大分県', 7),
('宮崎県', 7),
('鹿児島県', 7),
('沖縄県', 7)

ON CONFLICT (name) DO NOTHING;
</file>

<file path="backend/.pre-commit-config.yaml">
repos:
  - repo: local
    hooks:
      - id: go-fmt
        name: go fmt (gofumpt)
        entry: bash
        args: [-c, 'cd backend && go run mvdan.cc/gofumpt@latest -w .']
        language: system
        files: \.go$

      - id: go-imports
        name: go imports
        entry: bash
        args: [-c, 'cd backend && go run golang.org/x/tools/cmd/goimports@latest -w -local "github.com/AI1411/fullstack-react-go" .']
        language: system
        files: \.go$

      - id: go-vet
        name: go vet
        entry: bash
        args: [-c, 'cd backend && go vet ./...']
        language: system
        files: \.go$
        pass_filenames: false

      - id: staticcheck
        name: staticcheck
        entry: bash
        args: [-c, 'cd backend && go run honnef.co/go/tools/cmd/staticcheck@latest ./...']
        language: system
        files: \.go$
        pass_filenames: false

      - id: golangci-lint
        name: golangci-lint
        entry: bash
        args: [-c, 'cd backend && go run github.com/golangci/golangci-lint/cmd/golangci-lint@latest run --fix ./...']
        language: system
        files: \.go$
        pass_filenames: false

      - id: go-test
        name: go test
        entry: bash
        args: [-c, 'cd backend && go test ./...']
        language: system
        files: \.go$
        pass_filenames: false

  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.5.0
    hooks:
      - id: trailing-whitespace
      - id: end-of-file-fixer
      - id: check-yaml
      - id: check-merge-conflict
</file>

<file path="frontend/src/api/model/handlerListDisastersResponse.ts">
/**
 * Generated by orval v7.9.0 🍺
 * Do not edit manually.
 */

export interface HandlerListDisastersResponse {
  affected_area_size?: number
  disaster_code?: string
  disaster_type?: string
  estimated_damage_amount?: number
  id?: string
  impact_level?: string
  name?: string
  occurred_at?: string
  prefecture_id?: number
  status?: string
  summary?: string
}
</file>

<file path="frontend/src/api/model/index.ts">
/**
 * Generated by orval v7.9.0 🍺
 * Do not edit manually.
 */

export * from "./handlerListDisastersResponse"
</file>

<file path="frontend/src/api/client.msw.ts">
/**
 * Generated by orval v7.9.0 🍺
 * Do not edit manually.
 */
import { HttpResponse, delay, http } from "msw"

export const getListDisastersMockHandler = (
  overrideResponse?:
    | void
    | ((
        info: Parameters<Parameters<typeof http.get>[1]>[0]
      ) => Promise<void> | void)
) => {
  return http.get("*/disasters", async (info) => {
    await delay(1000)
    if (typeof overrideResponse === "function") {
      await overrideResponse(info)
    }
    return new HttpResponse(null, { status: 200 })
  })
}
export const getUndefinedMock = () => [getListDisastersMockHandler()]
</file>

<file path="frontend/src/api/client.ts">
/**
 * Generated by orval v7.9.0 🍺
 * Do not edit manually.
 */
import { useQuery } from "@tanstack/react-query"
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query"

import axios from "axios"
import type { AxiosError, AxiosRequestConfig, AxiosResponse } from "axios"

/**
 * @summary 災害マスタ一覧取得
 */
export const listDisasters = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<void>> => {
  return axios.get(`/disasters`, options)
}

export const getListDisastersQueryKey = () => {
  return [`/disasters`] as const
}

export const getListDisastersQueryOptions = <
  TData = Awaited<ReturnType<typeof listDisasters>>,
  TError = AxiosError<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof listDisasters>>, TError, TData>
  >
  axios?: AxiosRequestConfig
}) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getListDisastersQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listDisasters>>> = ({
    signal,
  }) => listDisasters({ signal, ...axiosOptions })

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listDisasters>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData> }
}

export type ListDisastersQueryResult = NonNullable<
  Awaited<ReturnType<typeof listDisasters>>
>
export type ListDisastersQueryError = AxiosError<unknown>

export function useListDisasters<
  TData = Awaited<ReturnType<typeof listDisasters>>,
  TError = AxiosError<unknown>,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listDisasters>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listDisasters>>,
          TError,
          Awaited<ReturnType<typeof listDisasters>>
        >,
        "initialData"
      >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData>
}
export function useListDisasters<
  TData = Awaited<ReturnType<typeof listDisasters>>,
  TError = AxiosError<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listDisasters>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listDisasters>>,
          TError,
          Awaited<ReturnType<typeof listDisasters>>
        >,
        "initialData"
      >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListDisasters<
  TData = Awaited<ReturnType<typeof listDisasters>>,
  TError = AxiosError<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listDisasters>>, TError, TData>
    >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary 災害マスタ一覧取得
 */

export function useListDisasters<
  TData = Awaited<ReturnType<typeof listDisasters>>,
  TError = AxiosError<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listDisasters>>, TError, TData>
    >
    axios?: AxiosRequestConfig
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {
  const queryOptions = getListDisastersQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData> }

  query.queryKey = queryOptions.queryKey

  return query
}
</file>

<file path="frontend/src/components/layout/footer/page.tsx">
import Link from "next/link"

const Footer = () => {
  return (
    <footer className="flex justify-center">
      <div className="flex max-w-[960px] flex-1 flex-col">
        <div className="flex flex-col gap-6 px-5 py-10 text-center @container">
          <div className="flex flex-wrap items-center justify-center gap-6 @[480px]:flex-row @[480px]:justify-around">
            <Link
              className="text-[#637588] text-base font-normal leading-normal min-w-40"
              href="#"
            >
              利用規約
            </Link>
            <Link
              className="text-[#637588] text-base font-normal leading-normal min-w-40"
              href="#"
            >
              プライバシーポリシー
            </Link>
            <Link
              className="text-[#637588] text-base font-normal leading-normal min-w-40"
              href="#"
            >
              お問い合わせ
            </Link>
          </div>
          <p className="text-[#637588] text-base font-normal leading-normal">
            @2024 アグリサポート. All rights reserved.
          </p>
        </div>
      </div>
    </footer>
  )
}

export default Footer
</file>

<file path="frontend/src/components/demo-component.tsx">
"use client"

import { useQuery } from "@tanstack/react-query"
import { fetchTodos } from "@/lib/api"
import { useCounterStore } from "@/lib/store"
import { Button } from "@/components/ui/button"

export function DemoComponent() {
  // Use zustand store
  const { count, increment, decrement, reset } = useCounterStore()

  // Use TanStack Query
  const {
    data: todos,
    isLoading,
    isError,
  } = useQuery({
    queryKey: ["todos"],
    queryFn: fetchTodos,
  })

  return (
    <div className="space-y-8">
      <div className="p-6 bg-gray-100 dark:bg-gray-800 rounded-lg">
        <h2 className="text-xl font-bold mb-4">Zustand State Management</h2>
        <div className="flex items-center gap-4 mb-4">
          <Button onClick={decrement} variant="outline">
            -
          </Button>
          <span className="text-2xl font-bold">{count}</span>
          <Button onClick={increment} variant="outline">
            +
          </Button>
        </div>
        <Button onClick={reset} variant="secondary">
          Reset
        </Button>
      </div>

      <div className="p-6 bg-gray-100 dark:bg-gray-800 rounded-lg">
        <h2 className="text-xl font-bold mb-4">TanStack Query Data Fetching</h2>
        {isLoading ? (
          <p>Loading todos...</p>
        ) : isError ? (
          <p className="text-red-500">Error loading todos</p>
        ) : (
          <ul className="space-y-2">
            {todos?.map((todo) => (
              <li key={todo.id} className="flex items-center gap-2">
                <span className={todo.completed ? "line-through" : ""}>
                  {todo.title}
                </span>
                <span className="text-xs px-2 py-1 rounded-full bg-gray-200 dark:bg-gray-700">
                  {todo.completed ? "Completed" : "Pending"}
                </span>
              </li>
            ))}
          </ul>
        )}
      </div>
    </div>
  )
}
</file>

<file path="frontend/src/lib/api.ts">
// Simple API utility functions for demonstration purposes

// Simulate a fetch request with a delay
const simulateFetch = <T>(data: T, delay: number = 1000): Promise<T> => {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(data)
    }, delay)
  })
}

// Example API endpoints
export const fetchTodos = async (): Promise<
  { id: number; title: string; completed: boolean }[]
> => {
  // Simulate API call
  return simulateFetch([
    { id: 1, title: "Learn React", completed: true },
    { id: 2, title: "Learn Next.js", completed: true },
    { id: 3, title: "Learn Zustand", completed: false },
    { id: 4, title: "Learn TanStack Query", completed: false },
  ])
}
</file>

<file path="frontend/src/lib/providers.tsx">
"use client"

import { QueryClient, QueryClientProvider } from "@tanstack/react-query"
import { useState } from "react"

export function Providers({ children }: { children: React.ReactNode }) {
  const [queryClient] = useState(
    () =>
      new QueryClient({
        defaultOptions: {
          queries: {
            staleTime: 60 * 1000, // 1 minute
            refetchOnWindowFocus: false,
          },
        },
      })
  )

  return (
    <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
  )
}
</file>

<file path="frontend/src/lib/store.ts">
import { create } from "zustand"

// Define the store state type
interface CounterState {
  count: number
  increment: () => void
  decrement: () => void
  reset: () => void
}

// Create the store
export const useCounterStore = create<CounterState>((set) => ({
  count: 0,
  increment: () => set((state) => ({ count: state.count + 1 })),
  decrement: () => set((state) => ({ count: state.count - 1 })),
  reset: () => set({ count: 0 }),
}))
</file>

<file path=".gitignore">
/backend/tmp
.idea/*
.env
backend/docs
</file>

<file path="README.md">
# 農地・農業用施設等災害復旧支援システム

自然災害による農地・農業用施設被害の拡大と地方公共団体の技術系職員減少に対応するための「災害事務ツール」です。被害情報のデータベースによる一元管理、所定様式への自動反映、リモート査定の実現により、地方公共団体職員の業務効率化・迅速化を図ります。

## 🏗️ システム構成

### バックエンド
- **言語**: Go 1.24
- **フレームワーク**: Gin Web Framework
- **データベース**: PostgreSQL 17
- **ORM**: GORM with Code Generation
- **依存関係注入**: Uber FX
- **API文書化**: Swagger

### フロントエンド
- **フレームワーク**: Next.js 15.3 (App Router)
- **言語**: TypeScript
- **スタイリング**: Tailwind CSS v4
- **状態管理**: Zustand
- **データフェッチング**: TanStack Query (React Query)
- **API型生成**: Orval
- **コンポーネント**: Radix UI + shadcn/ui

### インフラ・開発環境
- **コンテナ**: Docker & Docker Compose
- **データベースマイグレーション**: golang-migrate
- **ホットリロード**: Air (Go), Next.js dev server
- **リンター**: golangci-lint, Biome
- **コード整形**: gofumpt, goimports

## 🎯 主要機能

### 1. 基盤機能
- 認証・権限管理
- マスタデータ管理（災害種別、地域、施設種別等）
- ログ・監査機能

### 2. 被害情報管理
- 被害報告登録・検索
- 被害情報データベース一元管理
- 被害状況分析・可視化

### 3. 申請・手続き管理
- 申請書類自動作成
- 申請進捗管理
- 審査・承認ワークフロー

### 4. 帳票・出力機能
- 定型帳票自動生成
- カスタム帳票作成
- 一括処理

## 🚀 環境構築

### 必要な環境
- Docker & Docker Compose
- Node.js 18+ (フロントエンド開発時)
- Go 1.24+ (バックエンド開発時)
- pnpm (推奨)

### 1. リポジトリのクローン
```bash
git clone <repository-url>
cd fullstack-react-go
```

### 2. 環境変数の設定
```bash
cp .env.example .env
# 必要に応じて .env ファイルを編集
```

### 3. Docker環境の起動
```bash
# 全サービスを起動
docker compose up -d

# ログを確認
make logs
```

### 4. データベースのセットアップ
```bash
# マイグレーション実行
make migrate

# テストデータ投入（スキーマ全体）
make exec-schema
```

### 5. アプリケーションへのアクセス
- **フロントエンド**: http://localhost:3000
- **バックエンドAPI**: http://localhost:8080
- **API文書**: http://localhost:8080/docs
- **ヘルスチェック**: http://localhost:8080/health

## 🛠️ 開発コマンド

### バックエンド開発

```bash
# モデル再生成
make generate-models

# Swagger文書更新
make swag

# コード整形
make fmt

# 静的解析
make lint

# セキュリティチェック
make sec

# テスト実行
make test

# テストカバレッジ
make test-coverage

# 全品質チェック
make quality

# CI相当のチェック
make ci
```

### フロントエンド開発

```bash
cd frontend

# 開発サーバー起動
pnpm dev

# API型定義生成（Swagger JSONから）
pnpm generate

# コード整形・リント
pnpm lint

# ビルド
pnpm build
```

### データベース操作

```bash
# マイグレーション作成
make migrate-create

# マイグレーション実行
make migrate

# マイグレーション巻き戻し
make migrate-down

# マイグレーションバージョン確認
make migrate-version
```

## 📁 プロジェクト構造

```
.
├── backend/                 # Goバックエンド
│   ├── cmd/api/            # メインアプリケーション
│   ├── internal/           # プライベートコード
│   │   ├── domain/         # ドメインモデル・クエリ（自動生成）
│   │   ├── handler/        # HTTPハンドラー
│   │   ├── usecase/        # ビジネスロジック
│   │   ├── infra/          # インフラ層
│   │   └── middleware/     # ミドルウェア
│   ├── migrations/         # DBマイグレーション
│   └── docs/               # Swagger文書
├── frontend/               # Next.jsフロントエンド
│   ├── src/
│   │   ├── app/           # App Router
│   │   ├── components/    # Reactコンポーネント
│   │   ├── api/           # API型定義（自動生成）
│   │   └── lib/           # ユーティリティ
│   └── public/            # 静的ファイル
├── docker-compose.yml     # Docker設定
├── Makefile              # 開発タスク
└── README.md             # このファイル
```

## 🔧 開発ワークフロー

### 1. 新機能開発
1. データベーススキーマ変更（必要に応じて）
   ```bash
   make migrate-create
   # SQLファイルを編集
   make migrate
   ```

2. モデル再生成
   ```bash
   make generate-models
   ```

3. バックエンドAPIの実装
   - Handler → UseCase → Repository の順で実装
   - Swaggerアノテーションを追加

4. Swagger文書更新・API型生成
   ```bash
   make swag
   cd frontend && pnpm generate
   ```

5. フロントエンド実装
   - 生成された型・フックを使用してUI実装

### 2. コード品質管理
```bash
# 開発前の準備
make tools

# コミット前チェック
make fmt
make quality
make test
```

### 3. データベース設計

現在のスキーマ:
- **users**: ユーザー管理
- **regions**: 地域マスタ
- **prefectures**: 都道府県マスタ
- **disasters**: 災害情報（メインテーブル）

## 🔍 API エンドポイント

### 主要エンドポイント
- `GET /health` - ヘルスチェック
- `GET /disasters` - 災害一覧取得
- `GET /docs` - Swagger UI
- `GET /docs/swagger.json` - Swagger JSON

## 🧪 テスト

### バックエンドテスト
```bash
# 全テスト実行
make test

# カバレッジ付きテスト
make test-coverage
```

### 型安全性
- バックエンド: GORMによるコード生成で型安全なDB操作
- フロントエンド: OrvalによるSwagger→TypeScript型生成で型安全なAPI呼び出し

## 🚀 デプロイ

### 本番環境準備
1. 環境変数の設定
2. データベースのセットアップ
3. アプリケーションのビルド・起動

```bash
# プロダクションビルド
cd frontend && pnpm build
cd backend && go build -o main ./cmd/api
```

## 🔒 セキュリティ

- データベース接続の暗号化
- CORS設定
- 入力値バリデーション
- SQLインジェクション対策（GORM使用）
- 脆弱性チェック（govulncheck）

## 📖 参考資料

- [Gin Documentation](https://gin-gonic.com/docs/)
- [GORM Documentation](https://gorm.io/docs/)
- [Next.js Documentation](https://nextjs.org/docs)
- [TanStack Query Documentation](https://tanstack.com/query)
- [Tailwind CSS Documentation](https://tailwindcss.com/docs)

## 🤝 貢献

1. フォークしてブランチを作成
2. 変更を実装
3. テストを追加・実行
4. プルリクエストを作成

## 📄 ライセンス

このプロジェクトは [MIT License](LICENSE) の下で公開されています。
</file>

<file path="backend/cmd/gormgen/generate_associations/main.go">
package main

import (
	"context"

	"gorm.io/gen"

	"github.com/AI1411/fullstack-react-go/internal/infra/db"
	applogger "github.com/AI1411/fullstack-react-go/internal/infra/logger"
)

func main() {
	ctx := context.Background()
	g := gen.NewGenerator(gen.Config{
		OutPath:           "./internal/domain/query", // 出力パス
		Mode:              gen.WithoutContext | gen.WithDefaultQuery | gen.WithQueryInterface,
		FieldWithIndexTag: true,
		FieldWithTypeTag:  true,
		FieldNullable:     true,
	})

	sqlHandler, err := db.NewSqlHandler(
		db.DefaultDatabaseConfig(),
		applogger.New(applogger.DefaultConfig()),
	)
	if err != nil {
		panic(err)
	}

	g.UseDB(sqlHandler.Conn(ctx))

	// Generate the code
	g.Execute()

	// 生成したModelにRelation情報を手動追加（これだけは手動対応が必要）
	allModels := []any{
		g.GenerateModel("disasters"),
	}

	g.ApplyBasic(allModels...)

	// Generate the code
	g.Execute()
}
</file>

<file path="backend/internal/domain/model/disasters.gen.go">
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package model

import (
	"time"

	"gorm.io/gorm"
)

const TableNameDisaster = "disasters"

// Disaster mapped from table <disasters>
type Disaster struct {
	ID                    string         `gorm:"column:id;type:uuid;primaryKey;default:gen_random_uuid();comment:災害ID - 主キー" json:"id"`                                                                                                              // 災害ID - 主キー
	DisasterCode          string         `gorm:"column:disaster_code;type:character varying(20);not null;comment:災害コード - 管理用の一意識別子 (例: D2024-001)" json:"disaster_code"`                                                                             // 災害コード - 管理用の一意識別子 (例: D2024-001)
	Name                  string         `gorm:"column:name;type:character varying(100);not null;comment:災害名 - 災害の名称" json:"name"`                                                                                                                   // 災害名 - 災害の名称
	PrefectureID          int32          `gorm:"column:prefecture_id;type:integer;not null;index:idx_disasters_prefecture_id,priority:1;comment:都道府県ID - 災害が発生した都道府県のID" json:"prefecture_id"`                                                       // 都道府県ID - 災害が発生した都道府県のID
	OccurredAt            time.Time      `gorm:"column:occurred_at;type:timestamp with time zone;not null;index:idx_disasters_occurred_at,priority:1;comment:発生日時 - 災害が発生した日時" json:"occurred_at"`                                                   // 発生日時 - 災害が発生した日時
	Summary               string         `gorm:"column:summary;type:text;not null;comment:被害概要 - 災害による被害の詳細説明" json:"summary"`                                                                                                                       // 被害概要 - 災害による被害の詳細説明
	DisasterType          string         `gorm:"column:disaster_type;type:character varying(30);not null;index:idx_disasters_disaster_type,priority:1;comment:災害種別 - 洪水, 地滑り, 雹害, 干ばつ, 風害, 地震, 霜害, 病害虫など" json:"disaster_type"`                      // 災害種別 - 洪水, 地滑り, 雹害, 干ばつ, 風害, 地震, 霜害, 病害虫など
	Status                string         `gorm:"column:status;type:disaster_status;not null;index:idx_disasters_status,priority:1;default:pending;comment:状態 - pending(未着手), under_review(審査中), in_progress(対応中), completed(完了)のいずれか" json:"status"` // 状態 - pending(未着手), under_review(審査中), in_progress(対応中), completed(完了)のいずれか
	ImpactLevel           string         `gorm:"column:impact_level;type:character varying(20);not null;comment:被害レベル - 軽微, 中程度, 深刻, 甚大などの被害度合い" json:"impact_level"`                                                                                // 被害レベル - 軽微, 中程度, 深刻, 甚大などの被害度合い
	AffectedAreaSize      *float64       `gorm:"column:affected_area_size;type:numeric(10,2);comment:被害面積 - ヘクタール (ha) 単位での被害エリアの広さ" json:"affected_area_size"`                                                                                      // 被害面積 - ヘクタール (ha) 単位での被害エリアの広さ
	EstimatedDamageAmount *float64       `gorm:"column:estimated_damage_amount;type:numeric(15,2);comment:被害推定金額 - 円単位での被害総額" json:"estimated_damage_amount"`                                                                                        // 被害推定金額 - 円単位での被害総額
	CreatedAt             time.Time      `gorm:"column:created_at;type:timestamp with time zone;not null;default:CURRENT_TIMESTAMP;comment:作成日時 - レコード作成日時" json:"created_at"`                                                                       // 作成日時 - レコード作成日時
	UpdatedAt             time.Time      `gorm:"column:updated_at;type:timestamp with time zone;not null;default:CURRENT_TIMESTAMP;comment:更新日時 - レコード最終更新日時" json:"updated_at"`                                                                     // 更新日時 - レコード最終更新日時
	DeletedAt             gorm.DeletedAt `gorm:"column:deleted_at;type:timestamp with time zone;comment:削除日時 - 論理削除用のタイムスタンプ" json:"deleted_at"`                                                                                                     // 削除日時 - 論理削除用のタイムスタンプ
}

// TableName Disaster's table name
func (*Disaster) TableName() string {
	return TableNameDisaster
}
</file>

<file path="backend/internal/domain/query/disasters.gen.go">
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/AI1411/fullstack-react-go/internal/domain/model"
)

func newDisaster(db *gorm.DB, opts ...gen.DOOption) disaster {
	_disaster := disaster{}

	_disaster.disasterDo.UseDB(db, opts...)
	_disaster.disasterDo.UseModel(&model.Disaster{})

	tableName := _disaster.disasterDo.TableName()
	_disaster.ALL = field.NewAsterisk(tableName)
	_disaster.ID = field.NewString(tableName, "id")
	_disaster.DisasterCode = field.NewString(tableName, "disaster_code")
	_disaster.Name = field.NewString(tableName, "name")
	_disaster.PrefectureID = field.NewInt32(tableName, "prefecture_id")
	_disaster.OccurredAt = field.NewTime(tableName, "occurred_at")
	_disaster.Summary = field.NewString(tableName, "summary")
	_disaster.DisasterType = field.NewString(tableName, "disaster_type")
	_disaster.Status = field.NewString(tableName, "status")
	_disaster.ImpactLevel = field.NewString(tableName, "impact_level")
	_disaster.AffectedAreaSize = field.NewFloat64(tableName, "affected_area_size")
	_disaster.EstimatedDamageAmount = field.NewFloat64(tableName, "estimated_damage_amount")
	_disaster.CreatedAt = field.NewTime(tableName, "created_at")
	_disaster.UpdatedAt = field.NewTime(tableName, "updated_at")
	_disaster.DeletedAt = field.NewField(tableName, "deleted_at")

	_disaster.fillFieldMap()

	return _disaster
}

type disaster struct {
	disasterDo

	ALL                   field.Asterisk
	ID                    field.String  // 災害ID - 主キー
	DisasterCode          field.String  // 災害コード - 管理用の一意識別子 (例: D2024-001)
	Name                  field.String  // 災害名 - 災害の名称
	PrefectureID          field.Int32   // 都道府県ID - 災害が発生した都道府県のID
	OccurredAt            field.Time    // 発生日時 - 災害が発生した日時
	Summary               field.String  // 被害概要 - 災害による被害の詳細説明
	DisasterType          field.String  // 災害種別 - 洪水, 地滑り, 雹害, 干ばつ, 風害, 地震, 霜害, 病害虫など
	Status                field.String  // 状態 - pending(未着手), under_review(審査中), in_progress(対応中), completed(完了)のいずれか
	ImpactLevel           field.String  // 被害レベル - 軽微, 中程度, 深刻, 甚大などの被害度合い
	AffectedAreaSize      field.Float64 // 被害面積 - ヘクタール (ha) 単位での被害エリアの広さ
	EstimatedDamageAmount field.Float64 // 被害推定金額 - 円単位での被害総額
	CreatedAt             field.Time    // 作成日時 - レコード作成日時
	UpdatedAt             field.Time    // 更新日時 - レコード最終更新日時
	DeletedAt             field.Field   // 削除日時 - 論理削除用のタイムスタンプ

	fieldMap map[string]field.Expr
}

func (d disaster) Table(newTableName string) *disaster {
	d.disasterDo.UseTable(newTableName)
	return d.updateTableName(newTableName)
}

func (d disaster) As(alias string) *disaster {
	d.disasterDo.DO = *(d.disasterDo.As(alias).(*gen.DO))
	return d.updateTableName(alias)
}

func (d *disaster) updateTableName(table string) *disaster {
	d.ALL = field.NewAsterisk(table)
	d.ID = field.NewString(table, "id")
	d.DisasterCode = field.NewString(table, "disaster_code")
	d.Name = field.NewString(table, "name")
	d.PrefectureID = field.NewInt32(table, "prefecture_id")
	d.OccurredAt = field.NewTime(table, "occurred_at")
	d.Summary = field.NewString(table, "summary")
	d.DisasterType = field.NewString(table, "disaster_type")
	d.Status = field.NewString(table, "status")
	d.ImpactLevel = field.NewString(table, "impact_level")
	d.AffectedAreaSize = field.NewFloat64(table, "affected_area_size")
	d.EstimatedDamageAmount = field.NewFloat64(table, "estimated_damage_amount")
	d.CreatedAt = field.NewTime(table, "created_at")
	d.UpdatedAt = field.NewTime(table, "updated_at")
	d.DeletedAt = field.NewField(table, "deleted_at")

	d.fillFieldMap()

	return d
}

func (d *disaster) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := d.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (d *disaster) fillFieldMap() {
	d.fieldMap = make(map[string]field.Expr, 14)
	d.fieldMap["id"] = d.ID
	d.fieldMap["disaster_code"] = d.DisasterCode
	d.fieldMap["name"] = d.Name
	d.fieldMap["prefecture_id"] = d.PrefectureID
	d.fieldMap["occurred_at"] = d.OccurredAt
	d.fieldMap["summary"] = d.Summary
	d.fieldMap["disaster_type"] = d.DisasterType
	d.fieldMap["status"] = d.Status
	d.fieldMap["impact_level"] = d.ImpactLevel
	d.fieldMap["affected_area_size"] = d.AffectedAreaSize
	d.fieldMap["estimated_damage_amount"] = d.EstimatedDamageAmount
	d.fieldMap["created_at"] = d.CreatedAt
	d.fieldMap["updated_at"] = d.UpdatedAt
	d.fieldMap["deleted_at"] = d.DeletedAt
}

func (d disaster) clone(db *gorm.DB) disaster {
	d.disasterDo.ReplaceConnPool(db.Statement.ConnPool)
	return d
}

func (d disaster) replaceDB(db *gorm.DB) disaster {
	d.disasterDo.ReplaceDB(db)
	return d
}

type disasterDo struct{ gen.DO }

type IDisasterDo interface {
	gen.SubQuery
	Debug() IDisasterDo
	WithContext(ctx context.Context) IDisasterDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IDisasterDo
	WriteDB() IDisasterDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IDisasterDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IDisasterDo
	Not(conds ...gen.Condition) IDisasterDo
	Or(conds ...gen.Condition) IDisasterDo
	Select(conds ...field.Expr) IDisasterDo
	Where(conds ...gen.Condition) IDisasterDo
	Order(conds ...field.Expr) IDisasterDo
	Distinct(cols ...field.Expr) IDisasterDo
	Omit(cols ...field.Expr) IDisasterDo
	Join(table schema.Tabler, on ...field.Expr) IDisasterDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IDisasterDo
	RightJoin(table schema.Tabler, on ...field.Expr) IDisasterDo
	Group(cols ...field.Expr) IDisasterDo
	Having(conds ...gen.Condition) IDisasterDo
	Limit(limit int) IDisasterDo
	Offset(offset int) IDisasterDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IDisasterDo
	Unscoped() IDisasterDo
	Create(values ...*model.Disaster) error
	CreateInBatches(values []*model.Disaster, batchSize int) error
	Save(values ...*model.Disaster) error
	First() (*model.Disaster, error)
	Take() (*model.Disaster, error)
	Last() (*model.Disaster, error)
	Find() ([]*model.Disaster, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.Disaster, err error)
	FindInBatches(result *[]*model.Disaster, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.Disaster) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IDisasterDo
	Assign(attrs ...field.AssignExpr) IDisasterDo
	Joins(fields ...field.RelationField) IDisasterDo
	Preload(fields ...field.RelationField) IDisasterDo
	FirstOrInit() (*model.Disaster, error)
	FirstOrCreate() (*model.Disaster, error)
	FindByPage(offset int, limit int) (result []*model.Disaster, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IDisasterDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (d disasterDo) Debug() IDisasterDo {
	return d.withDO(d.DO.Debug())
}

func (d disasterDo) WithContext(ctx context.Context) IDisasterDo {
	return d.withDO(d.DO.WithContext(ctx))
}

func (d disasterDo) ReadDB() IDisasterDo {
	return d.Clauses(dbresolver.Read)
}

func (d disasterDo) WriteDB() IDisasterDo {
	return d.Clauses(dbresolver.Write)
}

func (d disasterDo) Session(config *gorm.Session) IDisasterDo {
	return d.withDO(d.DO.Session(config))
}

func (d disasterDo) Clauses(conds ...clause.Expression) IDisasterDo {
	return d.withDO(d.DO.Clauses(conds...))
}

func (d disasterDo) Returning(value interface{}, columns ...string) IDisasterDo {
	return d.withDO(d.DO.Returning(value, columns...))
}

func (d disasterDo) Not(conds ...gen.Condition) IDisasterDo {
	return d.withDO(d.DO.Not(conds...))
}

func (d disasterDo) Or(conds ...gen.Condition) IDisasterDo {
	return d.withDO(d.DO.Or(conds...))
}

func (d disasterDo) Select(conds ...field.Expr) IDisasterDo {
	return d.withDO(d.DO.Select(conds...))
}

func (d disasterDo) Where(conds ...gen.Condition) IDisasterDo {
	return d.withDO(d.DO.Where(conds...))
}

func (d disasterDo) Order(conds ...field.Expr) IDisasterDo {
	return d.withDO(d.DO.Order(conds...))
}

func (d disasterDo) Distinct(cols ...field.Expr) IDisasterDo {
	return d.withDO(d.DO.Distinct(cols...))
}

func (d disasterDo) Omit(cols ...field.Expr) IDisasterDo {
	return d.withDO(d.DO.Omit(cols...))
}

func (d disasterDo) Join(table schema.Tabler, on ...field.Expr) IDisasterDo {
	return d.withDO(d.DO.Join(table, on...))
}

func (d disasterDo) LeftJoin(table schema.Tabler, on ...field.Expr) IDisasterDo {
	return d.withDO(d.DO.LeftJoin(table, on...))
}

func (d disasterDo) RightJoin(table schema.Tabler, on ...field.Expr) IDisasterDo {
	return d.withDO(d.DO.RightJoin(table, on...))
}

func (d disasterDo) Group(cols ...field.Expr) IDisasterDo {
	return d.withDO(d.DO.Group(cols...))
}

func (d disasterDo) Having(conds ...gen.Condition) IDisasterDo {
	return d.withDO(d.DO.Having(conds...))
}

func (d disasterDo) Limit(limit int) IDisasterDo {
	return d.withDO(d.DO.Limit(limit))
}

func (d disasterDo) Offset(offset int) IDisasterDo {
	return d.withDO(d.DO.Offset(offset))
}

func (d disasterDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IDisasterDo {
	return d.withDO(d.DO.Scopes(funcs...))
}

func (d disasterDo) Unscoped() IDisasterDo {
	return d.withDO(d.DO.Unscoped())
}

func (d disasterDo) Create(values ...*model.Disaster) error {
	if len(values) == 0 {
		return nil
	}
	return d.DO.Create(values)
}

func (d disasterDo) CreateInBatches(values []*model.Disaster, batchSize int) error {
	return d.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (d disasterDo) Save(values ...*model.Disaster) error {
	if len(values) == 0 {
		return nil
	}
	return d.DO.Save(values)
}

func (d disasterDo) First() (*model.Disaster, error) {
	if result, err := d.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.Disaster), nil
	}
}

func (d disasterDo) Take() (*model.Disaster, error) {
	if result, err := d.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.Disaster), nil
	}
}

func (d disasterDo) Last() (*model.Disaster, error) {
	if result, err := d.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.Disaster), nil
	}
}

func (d disasterDo) Find() ([]*model.Disaster, error) {
	result, err := d.DO.Find()
	return result.([]*model.Disaster), err
}

func (d disasterDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.Disaster, err error) {
	buf := make([]*model.Disaster, 0, batchSize)
	err = d.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (d disasterDo) FindInBatches(result *[]*model.Disaster, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return d.DO.FindInBatches(result, batchSize, fc)
}

func (d disasterDo) Attrs(attrs ...field.AssignExpr) IDisasterDo {
	return d.withDO(d.DO.Attrs(attrs...))
}

func (d disasterDo) Assign(attrs ...field.AssignExpr) IDisasterDo {
	return d.withDO(d.DO.Assign(attrs...))
}

func (d disasterDo) Joins(fields ...field.RelationField) IDisasterDo {
	for _, _f := range fields {
		d = *d.withDO(d.DO.Joins(_f))
	}
	return &d
}

func (d disasterDo) Preload(fields ...field.RelationField) IDisasterDo {
	for _, _f := range fields {
		d = *d.withDO(d.DO.Preload(_f))
	}
	return &d
}

func (d disasterDo) FirstOrInit() (*model.Disaster, error) {
	if result, err := d.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.Disaster), nil
	}
}

func (d disasterDo) FirstOrCreate() (*model.Disaster, error) {
	if result, err := d.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.Disaster), nil
	}
}

func (d disasterDo) FindByPage(offset int, limit int) (result []*model.Disaster, count int64, err error) {
	result, err = d.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = d.Offset(-1).Limit(-1).Count()
	return
}

func (d disasterDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = d.Count()
	if err != nil {
		return
	}

	err = d.Offset(offset).Limit(limit).Scan(result)
	return
}

func (d disasterDo) Scan(result interface{}) (err error) {
	return d.DO.Scan(result)
}

func (d disasterDo) Delete(models ...*model.Disaster) (result gen.ResultInfo, err error) {
	return d.DO.Delete(models)
}

func (d *disasterDo) withDO(do gen.Dao) *disasterDo {
	d.DO = *do.(*gen.DO)
	return d
}
</file>

<file path="backend/internal/infra/db/client.go">
package db

import (
	"context"
	"errors"
	"fmt"
	"log"
	"time"

	"gorm.io/driver/postgres"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"

	applogger "github.com/AI1411/fullstack-react-go/internal/infra/logger"
)

// Client インターフェース
type Client interface {
	Conn(ctx context.Context) *gorm.DB
	Close() error
	Ping(ctx context.Context) error
	Transaction(ctx context.Context, fn func(tx Client) error) error
}

// SQLLogger インターフェース
type SQLLogger interface {
	logger.Interface
}

// SqlHandler はDatabaseHandlerの実装
type SqlHandler struct {
	conn *gorm.DB
}

// JSONLogger is a custom GORM logger that uses our application's JSON logger
type JSONLogger struct {
	logger        *applogger.Logger
	slowThreshold time.Duration
	logLevel      logger.LogLevel
}

// NewJSONLogger creates a new JSONLogger
func NewJSONLogger(appLogger *applogger.Logger) SQLLogger {
	return &JSONLogger{
		logger:        appLogger,
		slowThreshold: time.Second,
		logLevel:      logger.Info,
	}
}

// LogMode sets the log level
func (l *JSONLogger) LogMode(level logger.LogLevel) logger.Interface {
	newLogger := *l
	newLogger.logLevel = level

	return &newLogger
}

// Info logs info messages
func (l *JSONLogger) Info(ctx context.Context, msg string, data ...interface{}) {
	if l.logLevel >= logger.Info {
		l.logger.Info(msg, "data", data)
	}
}

// Warn logs warn messages
func (l *JSONLogger) Warn(ctx context.Context, msg string, data ...interface{}) {
	if l.logLevel >= logger.Warn {
		l.logger.Info(msg, "data", data)
	}
}

// Error logs error messages
func (l *JSONLogger) Error(ctx context.Context, msg string, data ...interface{}) {
	if l.logLevel >= logger.Error {
		l.logger.LogError(errors.New(msg), msg, "data", data)
	}
}

// Trace logs SQL statements with execution time
func (l *JSONLogger) Trace(ctx context.Context, begin time.Time, fc func() (string, int64), err error) {
	if l.logLevel <= logger.Silent {
		return
	}

	elapsed := time.Since(begin)
	sql, rows := fc()

	if err != nil {
		l.logger.LogError(err, "SQL error",
			"sql", sql,
			"rows", rows,
			"elapsed", elapsed)

		return
	}

	if l.slowThreshold != 0 && elapsed > l.slowThreshold {
		l.logger.Info("SLOW SQL",
			"sql", sql,
			"rows", rows,
			"elapsed", elapsed)

		return
	}

	if l.logLevel >= logger.Info {
		l.logger.Info("SQL",
			"sql", sql,
			"rows", rows,
			"elapsed", elapsed)
	}
}

// DatabaseConfig データベース設定
type DatabaseConfig struct {
	Host            string
	Port            string
	User            string
	Password        string
	DBName          string
	SSLMode         string
	Timezone        string
	MaxIdleConns    int
	MaxOpenConns    int
	ConnMaxLifetime time.Duration
}

// DefaultDatabaseConfig デフォルト設定を返す
func DefaultDatabaseConfig() *DatabaseConfig {
	return &DatabaseConfig{
		Host:            "db",
		Port:            "5432",
		User:            "postgres",
		Password:        "postgres",
		DBName:          "gen",
		SSLMode:         "disable",
		Timezone:        "Asia/Tokyo",
		MaxIdleConns:    10,
		MaxOpenConns:    100,
		ConnMaxLifetime: time.Hour,
	}
}

// NewSqlHandler creates a new SqlHandler
func NewSqlHandler(config *DatabaseConfig, appLogger *applogger.Logger) (Client, error) {
	if config == nil {
		config = DefaultDatabaseConfig()
	}

	// PostgreSQL形式の接続文字列
	dsn := fmt.Sprintf("host=%s user=%s password=%s dbname=%s port=%s sslmode=%s TimeZone=%s",
		config.Host, config.User, config.Password, config.DBName, config.Port, config.SSLMode, config.Timezone)

	log.Printf("dsn=%s", dsn)

	// PostgreSQLに直接接続
	db, err := gorm.Open(postgres.Open(dsn), &gorm.Config{
		Logger: NewJSONLogger(appLogger),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to connect to database: %w", err)
	}

	// 接続プールの設定
	sqlDB, err := db.DB()
	if err != nil {
		return nil, fmt.Errorf("failed to get underlying sql.DB: %w", err)
	}

	// 接続プールの設定
	sqlDB.SetMaxIdleConns(config.MaxIdleConns)
	sqlDB.SetMaxOpenConns(config.MaxOpenConns)
	sqlDB.SetConnMaxLifetime(config.ConnMaxLifetime)

	return &SqlHandler{
		conn: db,
	}, nil
}

// Conn returns the underlying GORM DB instance
func (s *SqlHandler) Conn(ctx context.Context) *gorm.DB {
	return s.conn.WithContext(ctx)
}

// Close closes the database connection
func (s *SqlHandler) Close() error {
	sqlDB, err := s.conn.DB()
	if err != nil {
		return fmt.Errorf("failed to get underlying sql.DB: %w", err)
	}

	return sqlDB.Close()
}

// Ping verifies a connection to the database is still alive
func (s *SqlHandler) Ping(ctx context.Context) error {
	sqlDB, err := s.conn.DB()
	if err != nil {
		return fmt.Errorf("failed to get underlying sql.DB: %w", err)
	}

	return sqlDB.PingContext(ctx)
}

// Transaction executes a function within a database transaction
func (s *SqlHandler) Transaction(ctx context.Context, fn func(tx Client) error) error {
	return s.conn.WithContext(ctx).Transaction(func(tx *gorm.DB) error {
		txHandler := &SqlHandler{conn: tx}
		return fn(txHandler)
	})
}

// NewSqlHandlerFromParams creates a new SqlHandler from individual parameters (for backward compatibility)
func NewSqlHandlerFromParams(userID, password, host, port, dbName string, appLogger *applogger.Logger) (Client, error) {
	config := &DatabaseConfig{
		Host:            host,
		Port:            port,
		User:            userID,
		Password:        password,
		DBName:          dbName,
		SSLMode:         "disable",
		Timezone:        "Asia/Tokyo",
		MaxIdleConns:    10,
		MaxOpenConns:    100,
		ConnMaxLifetime: time.Hour,
	}

	return NewSqlHandler(config, appLogger)
}

// MockDatabaseHandler テスト用のモック実装
type MockDatabaseHandler struct {
	db           *gorm.DB
	shouldError  bool
	errorMessage string
}

// NewMockDatabaseHandler creates a new mock database handler
func NewMockDatabaseHandler() Client {
	return &MockDatabaseHandler{
		db: &gorm.DB{}, // ダミーのGORMインスタンス
	}
}

// Conn returns the mock GORM DB instance
func (m *MockDatabaseHandler) Conn(ctx context.Context) *gorm.DB {
	return m.db.WithContext(ctx)
}

// Close closes the mock connection
func (m *MockDatabaseHandler) Close() error {
	if m.shouldError {
		return errors.New(m.errorMessage)
	}

	return nil
}

// Ping verifies mock connection
func (m *MockDatabaseHandler) Ping(ctx context.Context) error {
	if m.shouldError {
		return errors.New(m.errorMessage)
	}

	return nil
}

// Transaction executes a function within a mock transaction
func (m *MockDatabaseHandler) Transaction(ctx context.Context, fn func(tx Client) error) error {
	if m.shouldError {
		return errors.New(m.errorMessage)
	}

	return fn(m)
}

// SetError sets the mock to return errors
func (m *MockDatabaseHandler) SetError(shouldError bool, message string) {
	m.shouldError = shouldError
	m.errorMessage = message
}
</file>

<file path="frontend/src/app/disasters/[id]/page.tsx">
"use client"

import Footer from "@/components/layout/footer/page"
import Header from "@/components/layout/header/page"
import Link from "next/link"
import { notFound } from "next/navigation"
import { useState } from "react"

// サンプルデータ。IDに対応する詳細情報を含める
const disasterDetailsData: { [key: string]: any } = {
  "1": {
    id: "2023-001",
    name: "台風ラン",
    date: "2023年8月15日",
    type: "台風",
    location: "京都府",
    affectedArea: "150ヘクタール",
    estimatedDamage: "5億円",
    damageSummary: {
      total: 120,
      farmlands: 80,
      facilities: 40,
    },
    timeline: [
      {
        date: "2023年8月14日 09:00",
        event: "気象庁より台風接近の警報発令",
        status: "警報",
        details: "台風12号が近畿地方に接近中。京都府南部に暴風警報発令。",
      },
      {
        date: "2023年8月15日 06:30",
        event: "災害対策本部設置",
        status: "対応",
        details: "京都府農林水産部に災害対策本部を設置。被害状況の収集を開始。",
      },
      {
        date: "2023年8月15日 13:45",
        event: "最初の被害報告",
        status: "被害",
        details: "南丹市から農地冠水の第一報。約20ヘクタールの水田が被害。",
      },
      {
        date: "2023年8月15日 19:20",
        event: "被害拡大",
        status: "被害",
        details:
          "亀岡市、京田辺市からも被害報告。被害面積が100ヘクタールを超える見込み。",
      },
      {
        date: "2023年8月16日 08:00",
        event: "現地調査開始",
        status: "調査",
        details: "被害調査班3チームが現地調査を開始。",
      },
      {
        date: "2023年8月17日 10:30",
        event: "緊急支援決定",
        status: "支援",
        details:
          "農林水産省と連携し、緊急支援策を決定。復旧作業の資金支援を開始。",
      },
      {
        date: "2023年8月20日 15:00",
        event: "被害確定報告書提出",
        status: "報告",
        details: "最終的な被害状況を取りまとめ、農林水産省へ報告書を提出。",
      },
    ],
    documents: [
      {
        name: "被害報告書 2023-001",
        type: "報告書",
        uploaded: "2023年8月16日",
      },
      {
        name: "申請書 2023-001",
        type: "申請書",
        uploaded: "2023年8月17日",
      },
      {
        name: "評価レポート 2023-001",
        type: "レポート",
        uploaded: "2023年8月20日",
      },
    ],
  },
  "2": {
    id: "2023-002",
    name: "大阪水害",
    date: "2024年7月10日",
    type: "洪水",
    location: "大阪府",
    affectedArea: "120ヘクタール",
    estimatedDamage: "3億5000万円",
    damageSummary: {
      total: 95,
      farmlands: 65,
      facilities: 30,
    },
    timeline: [
      {
        date: "2024年7月9日 18:00",
        event: "大雨特別警報発令",
        status: "警報",
        details: "気象庁より大阪府北部に大雨特別警報が発令。",
      },
      {
        date: "2024年7月10日 02:30",
        event: "河川氾濫発生",
        status: "被害",
        details: "淀川水系の支流が複数箇所で氾濫。農地への浸水被害が発生。",
      },
      {
        date: "2024年7月10日 07:00",
        event: "災害対策本部設置",
        status: "対応",
        details: "大阪府農政部に災害対策本部を設置。",
      },
      {
        date: "2024年7月11日 09:15",
        event: "現地調査開始",
        status: "調査",
        details: "被害状況の調査を開始。ドローンによる空撮も実施。",
      },
      {
        date: "2024年7月12日 14:00",
        event: "支援対策決定",
        status: "支援",
        details: "被災農家への支援策を決定。復旧資金の緊急融資を開始。",
      },
    ],
    documents: [
      {
        name: "被害報告書 2023-002",
        type: "報告書",
        uploaded: "2024年7月11日",
      },
      {
        name: "申請書 2023-002",
        type: "申請書",
        uploaded: "2024年7月12日",
      },
    ],
  },
  "3": {
    id: "2023-003",
    name: "兵庫県雹害",
    date: "2024年7月5日",
    type: "雹害",
    location: "兵庫県",
    affectedArea: "85ヘクタール",
    estimatedDamage: "2億2000万円",
    damageSummary: {
      total: 70,
      farmlands: 55,
      facilities: 15,
    },
    documents: [
      {
        name: "被害報告書 2023-003",
        type: "報告書",
        uploaded: "2024年7月6日",
      },
    ],
  },
  "4": {
    id: "2023-004",
    name: "奈良県干ばつ",
    date: "2024年6月28日",
    type: "干ばつ",
    location: "奈良県",
    affectedArea: "200ヘクタール",
    estimatedDamage: "4億円",
    damageSummary: {
      total: 110,
      farmlands: 95,
      facilities: 15,
    },
    documents: [
      {
        name: "被害報告書 2023-004",
        type: "報告書",
        uploaded: "2024年6月29日",
      },
    ],
  },
  "5": {
    id: "2023-005",
    name: "滋賀県強風被害",
    date: "2024年6月20日",
    type: "強風",
    location: "滋賀県",
    affectedArea: "70ヘクタール",
    estimatedDamage: "1億8000万円",
    damageSummary: {
      total: 60,
      farmlands: 35,
      facilities: 25,
    },
    documents: [
      {
        name: "被害報告書 2023-005",
        type: "報告書",
        uploaded: "2024年6月21日",
      },
    ],
  },
  "6": {
    id: "2023-006",
    name: "和歌山県水害",
    date: "2024年6月12日",
    type: "洪水",
    location: "和歌山県",
    affectedArea: "110ヘクタール",
    estimatedDamage: "2億8000万円",
    damageSummary: {
      total: 85,
      farmlands: 65,
      facilities: 20,
    },
    documents: [
      {
        name: "被害報告書 2023-006",
        type: "報告書",
        uploaded: "2024年6月13日",
      },
    ],
  },
  "7": {
    id: "2023-007",
    name: "三重県地滑り",
    date: "2024年6月5日",
    type: "地滑り",
    location: "三重県",
    affectedArea: "60ヘクタール",
    estimatedDamage: "1億5000万円",
    damageSummary: {
      total: 45,
      farmlands: 30,
      facilities: 15,
    },
    documents: [
      {
        name: "被害報告書 2023-007",
        type: "報告書",
        uploaded: "2024年6月6日",
      },
    ],
  },
  "8": {
    id: "2023-008",
    name: "愛知県雹害",
    date: "2024年5月28日",
    type: "雹害",
    location: "愛知県",
    affectedArea: "75ヘクタール",
    estimatedDamage: "1億9000万円",
    damageSummary: {
      total: 65,
      farmlands: 50,
      facilities: 15,
    },
    documents: [
      {
        name: "被害報告書 2023-008",
        type: "報告書",
        uploaded: "2024年5月29日",
      },
    ],
  },
  "9": {
    id: "2023-009",
    name: "岐阜県干ばつ",
    date: "2024年5月20日",
    type: "干ばつ",
    location: "岐阜県",
    affectedArea: "180ヘクタール",
    estimatedDamage: "3億2000万円",
    damageSummary: {
      total: 90,
      farmlands: 75,
      facilities: 15,
    },
    documents: [
      {
        name: "被害報告書 2023-009",
        type: "報告書",
        uploaded: "2024年5月21日",
      },
    ],
  },
  "10": {
    id: "2023-010",
    name: "静岡県強風被害",
    date: "2024年5月12日",
    type: "強風",
    location: "静岡県",
    affectedArea: "65ヘクタール",
    estimatedDamage: "1億7000万円",
    damageSummary: {
      total: 55,
      farmlands: 40,
      facilities: 15,
    },
    documents: [
      {
        name: "被害報告書 2023-010",
        type: "報告書",
        uploaded: "2024年5月13日",
      },
    ],
  },
}

const getDisasterById = (id: string) => {
  // 実際のIDは "2023-001" のような形式かもしれませんが、
  // URLの "1" とマッピングさせるため、ここでは "1" をキーとします。
  return disasterDetailsData[id]
}

type Props = {
  params: { id: string }
}

export default function DisasterDetailPage({ params }: Props) {
  const disaster = getDisasterById(params.id)
  const [activeTab, setActiveTab] = useState<
    "overview" | "damages" | "documents" | "timeline"
  >("overview")

  if (!disaster) {
    notFound()
  }

  return (
    <div className="layout-container flex h-full grow flex-col">
      <Header />
      <main className="px-40 flex flex-1 justify-center py-5">
        <div className="layout-content-container flex flex-col max-w-[960px] flex-1">
          {/* Breadcrumbs */}
          <div className="flex flex-wrap gap-2 p-4">
            <Link
              href="/"
              className="text-[#637588] text-base font-medium leading-normal hover:underline"
            >
              TOP
            </Link>
            <span className="text-[#637588] text-base font-medium leading-normal">
              /
            </span>
            <Link
              href="/disasters"
              className="text-[#637588] text-base font-medium leading-normal hover:underline"
            >
              災害リスト
            </Link>
            <span className="text-[#637588] text-base font-medium leading-normal">
              /
            </span>
            <span className="text-[#111418] text-base font-medium leading-normal">
              災害詳細
            </span>
          </div>

          {/* Page Header */}
          <div className="flex flex-wrap justify-between gap-3 p-4">
            <div className="flex min-w-72 flex-col gap-3">
              <p className="text-[#111418] tracking-light text-[32px] font-bold leading-tight">
                災害 #{disaster.id}
              </p>
              <p className="text-[#637588] text-sm font-normal leading-normal">
                {disaster.name}, {disaster.date}
              </p>
            </div>
          </div>

          <div className="pb-3">
            <div className="flex border-b border-[#dce0e5] px-4 gap-8">
              <button
                className={`flex flex-col items-center justify-center border-b-[3px] ${
                  activeTab === "overview"
                    ? "border-b-[#111418] text-[#111418]"
                    : "border-b-transparent text-[#637588]"
                } pb-[13px] pt-4 cursor-pointer`}
                onClick={() => setActiveTab("overview")}
              >
                <p
                  className={`${activeTab === "overview" ? "text-[#111418]" : "text-[#637588]"} text-sm font-bold leading-normal tracking-[0.015em]`}
                >
                  概要
                </p>
              </button>
              <button
                className={`flex flex-col items-center justify-center border-b-[3px] ${
                  activeTab === "damages"
                    ? "border-b-[#111418] text-[#111418]"
                    : "border-b-transparent text-[#637588]"
                } pb-[13px] pt-4 cursor-pointer`}
                onClick={() => setActiveTab("damages")}
              >
                <p
                  className={`${activeTab === "damages" ? "text-[#111418]" : "text-[#637588]"} text-sm font-bold leading-normal tracking-[0.015em]`}
                >
                  被害状況
                </p>
              </button>
              <button
                className={`flex flex-col items-center justify-center border-b-[3px] ${
                  activeTab === "documents"
                    ? "border-b-[#111418] text-[#111418]"
                    : "border-b-transparent text-[#637588]"
                } pb-[13px] pt-4 cursor-pointer`}
                onClick={() => setActiveTab("documents")}
              >
                <p
                  className={`${activeTab === "documents" ? "text-[#111418]" : "text-[#637588]"} text-sm font-bold leading-normal tracking-[0.015em]`}
                >
                  関連書類
                </p>
              </button>
              <button
                className={`flex flex-col items-center justify-center border-b-[3px] ${
                  activeTab === "timeline"
                    ? "border-b-[#111418] text-[#111418]"
                    : "border-b-transparent text-[#637588]"
                } pb-[13px] pt-4 cursor-pointer`}
                onClick={() => setActiveTab("timeline")}
              >
                <p
                  className={`${activeTab === "timeline" ? "text-[#111418]" : "text-[#637588]"} text-sm font-bold leading-normal tracking-[0.015em]`}
                >
                  タイムライン
                </p>
              </button>
            </div>
          </div>

          {/* Disaster Overview Section */}
          {activeTab === "overview" && (
            <>
              <h2 className="text-[#111418] text-[22px] font-bold leading-tight tracking-[-0.015em] px-4 pb-3 pt-5">
                災害概要
              </h2>
              <div className="p-4 grid grid-cols-[20%_1fr] gap-x-6">
                <div className="col-span-2 grid grid-cols-subgrid border-t border-t-[#dce0e5] py-5">
                  <p className="text-[#637588] text-sm font-normal leading-normal">
                    災害種別
                  </p>
                  <p className="text-[#111418] text-sm font-normal leading-normal">
                    {disaster.type}
                  </p>
                </div>
                <div className="col-span-2 grid grid-cols-subgrid border-t border-t-[#dce0e5] py-5">
                  <p className="text-[#637588] text-sm font-normal leading-normal">
                    発生場所
                  </p>
                  <p className="text-[#111418] text-sm font-normal leading-normal">
                    {disaster.location}
                  </p>
                </div>
                <div className="col-span-2 grid grid-cols-subgrid border-t border-t-[#dce0e5] py-5">
                  <p className="text-[#637588] text-sm font-normal leading-normal">
                    発生日
                  </p>
                  <p className="text-[#111418] text-sm font-normal leading-normal">
                    {disaster.date}
                  </p>
                </div>
                <div className="col-span-2 grid grid-cols-subgrid border-t border-t-[#dce0e5] py-5">
                  <p className="text-[#637588] text-sm font-normal leading-normal">
                    被災面積
                  </p>
                  <p className="text-[#111418] text-sm font-normal leading-normal">
                    {disaster.affectedArea}
                  </p>
                </div>
                <div className="col-span-2 grid grid-cols-subgrid border-t border-t-[#dce0e5] py-5">
                  <p className="text-[#637588] text-sm font-normal leading-normal">
                    推定被害額
                  </p>
                  <p className="text-[#111418] text-sm font-normal leading-normal">
                    {disaster.estimatedDamage}
                  </p>
                </div>
              </div>
            </>
          )}

          {/* Damage Summary Section */}
          {activeTab === "damages" && (
            <>
              <h2 className="text-[#111418] text-[22px] font-bold leading-tight tracking-[-0.015em] px-4 pb-3 pt-5">
                被害状況
              </h2>
              <div className="flex flex-wrap gap-4 p-4">
                <div className="flex min-w-[158px] flex-1 flex-col gap-2 rounded-lg p-6 border border-[#dce0e5]">
                  <p className="text-[#111418] text-base font-medium leading-normal">
                    総被害件数
                  </p>
                  <p className="text-[#111418] tracking-light text-2xl font-bold leading-tight">
                    {disaster.damageSummary.total}
                  </p>
                </div>
                <div className="flex min-w-[158px] flex-1 flex-col gap-2 rounded-lg p-6 border border-[#dce0e5]">
                  <p className="text-[#111418] text-base font-medium leading-normal">
                    農地被害
                  </p>
                  <p className="text-[#111418] tracking-light text-2xl font-bold leading-tight">
                    {disaster.damageSummary.farmlands}
                  </p>
                </div>
                <div className="flex min-w-[158px] flex-1 flex-col gap-2 rounded-lg p-6 border border-[#dce0e5]">
                  <p className="text-[#111418] text-base font-medium leading-normal">
                    施設被害
                  </p>
                  <p className="text-[#111418] tracking-light text-2xl font-bold leading-tight">
                    {disaster.damageSummary.facilities}
                  </p>
                </div>
              </div>
            </>
          )}

          {/* Related Documents Section */}
          {activeTab === "documents" && (
            <>
              <h2 className="text-[#111418] text-[22px] font-bold leading-tight tracking-[-0.015em] px-4 pb-3 pt-5">
                関連書類
              </h2>
              <div className="px-4 py-3 @container">
                <div className="flex overflow-hidden rounded-lg border border-[#dce0e5] bg-white">
                  <table className="flex-1">
                    <thead>
                      <tr className="bg-white">
                        <th className="table-column-120 px-4 py-3 text-left text-[#111418] w-[400px] text-sm font-medium leading-normal">
                          書類名
                        </th>
                        <th className="table-column-240 px-4 py-3 text-left text-[#111418] w-[400px] text-sm font-medium leading-normal">
                          種類
                        </th>
                        <th className="table-column-360 px-4 py-3 text-left text-[#111418] w-[400px] text-sm font-medium leading-normal">
                          アップロード日
                        </th>
                        <th className="table-column-480 px-4 py-3 text-left text-[#111418] w-60 text-[#637588] text-sm font-medium leading-normal">
                          アクション
                        </th>
                      </tr>
                    </thead>
                    <tbody>
                      {disaster.documents.map((doc: any, index: number) => (
                        <tr key={index} className="border-t border-t-[#dce0e5]">
                          <td className="table-column-120 h-[72px] px-4 py-2 w-[400px] text-[#111418] text-sm font-normal leading-normal">
                            {doc.name}
                          </td>
                          <td className="table-column-240 h-[72px] px-4 py-2 w-[400px] text-[#637588] text-sm font-normal leading-normal">
                            {doc.type}
                          </td>
                          <td className="table-column-360 h-[72px] px-4 py-2 w-[400px] text-[#637588] text-sm font-normal leading-normal">
                            {doc.uploaded}
                          </td>
                          <td className="table-column-480 h-[72px] px-4 py-2 w-60 text-[#637588] text-sm font-bold leading-normal tracking-[0.015em]">
                            <Link
                              href="#"
                              className="text-blue-600 hover:underline"
                            >
                              表示
                            </Link>
                          </td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                </div>
              </div>
            </>
          )}

          {/* Timeline Section */}
          {activeTab === "timeline" && (
            <>
              <h2 className="text-[#111418] text-[22px] font-bold leading-tight tracking-[-0.015em] px-4 pb-3 pt-5">
                タイムライン
              </h2>
              <div className="p-4">
                <div className="flex flex-col gap-4 border border-[#dce0e5] rounded-lg p-6">
                  {disaster.timeline ? (
                    <div className="relative">
                      {disaster.timeline.map((item: any, index: number) => (
                        <div key={index} className="mb-8 ml-6 relative">
                          {/* 縦線 */}
                          {index < disaster.timeline.length - 1 && (
                            <div className="absolute left-[-24px] top-[24px] bottom-[-32px] w-[2px] bg-[#dce0e5]"></div>
                          )}

                          {/* タイムラインの丸いポイント */}
                          <div className="absolute left-[-30px] top-0 h-[12px] w-[12px] rounded-full border-4 border-white bg-blue-500"></div>

                          <div className="flex flex-col gap-1">
                            {/* 日付 */}
                            <p className="text-[#637588] text-sm font-medium leading-normal">
                              {item.date}
                            </p>

                            {/* イベント名とステータス */}
                            <div className="flex items-center gap-2">
                              <h3 className="text-[#111418] text-base font-bold leading-normal">
                                {item.event}
                              </h3>
                              <span
                                className={`px-2 py-1 rounded-full text-xs font-medium ${
                                  item.status === "警報"
                                    ? "bg-red-100 text-red-800"
                                    : item.status === "被害"
                                      ? "bg-orange-100 text-orange-800"
                                      : item.status === "対応"
                                        ? "bg-blue-100 text-blue-800"
                                        : item.status === "調査"
                                          ? "bg-purple-100 text-purple-800"
                                          : item.status === "支援"
                                            ? "bg-green-100 text-green-800"
                                            : item.status === "報告"
                                              ? "bg-gray-100 text-gray-800"
                                              : "bg-gray-100 text-gray-800"
                                }`}
                              >
                                {item.status}
                              </span>
                            </div>

                            {/* 詳細 */}
                            <p className="text-[#111418] text-sm font-normal leading-normal">
                              {item.details}
                            </p>
                          </div>
                        </div>
                      ))}
                    </div>
                  ) : (
                    <p className="text-[#111418] text-base font-medium leading-normal">
                      このリストの災害にはタイムライン情報がありません。
                    </p>
                  )}
                </div>
              </div>
            </>
          )}
        </div>
      </main>
      <Footer />
    </div>
  )
}
</file>

<file path="frontend/src/app/disasters/page.tsx">
"use client"

import Footer from "@/components/layout/footer/page"
import Header from "@/components/layout/header/page"
import Link from "next/link"
import { useListDisasters } from "@/api/client"
import { HandlerListDisastersResponse } from "@/api/model"
import { LoadingSpinner, LoadingTable } from "@/components/ui/loading"
import { ErrorDisplay, EmptyState } from "@/components/ui/error-display"
import { useErrorHandler } from "@/hooks/useErrorHandler"
import { FileX } from "lucide-react"

// ステータスに応じたバッジの色を定義
const getStatusBadgeClass = (status: string) => {
  switch (status) {
    case "pending":
      return "bg-[#fff7e6] text-[#ff8b00]"
    case "under_review":
      return "bg-[#edf5ff] text-[#0055cc]"
    case "in_progress":
      return "bg-[#f0f2f4] text-[#111418]"
    case "completed":
      return "bg-[#e6fcf5] text-[#00a3bf]"
    default:
      return "bg-[#f0f2f4] text-[#111418]"
  }
}

// ステータスの日本語表示
const getStatusLabel = (status: string) => {
  switch (status) {
    case "pending":
      return "未着手"
    case "under_review":
      return "審査中"
    case "in_progress":
      return "対応中"
    case "completed":
      return "完了"
    default:
      return status
  }
}

// 日付フォーマット関数
const formatDate = (dateString: string) => {
  const date = new Date(dateString)
  return date.toLocaleDateString('ja-JP', {
    year: 'numeric',
    month: '2-digit',
    day: '2-digit'
  })
}

export default function DisasterInfoPage() {
  const { handleError } = useErrorHandler()

  // API呼び出し
  const {
    data: disastersResponse,
    isLoading,
    isError,
    error,
    refetch
  } = useListDisasters({
    query: {
      retry: 3,
      staleTime: 5 * 60 * 1000, // 5分間キャッシュ
    }
  })

  // レスポンスからデータを取得
  const disasters = disastersResponse?.data || []

  // エラーハンドリング
  const apiError = isError ? handleError(error) : null

  return (
    <div className="layout-container flex h-full grow flex-col">
      <Header />
      <main className="px-40 flex flex-1 justify-center py-5">
        <div className="layout-content-container flex flex-col max-w-[960px] flex-1">
          <div className="flex flex-wrap justify-between gap-3 p-4">
            <div className="flex min-w-72 flex-col gap-3">
              <p className="text-[#111418] tracking-light text-[32px] font-bold leading-tight">
                災害情報リスト
              </p>
              <p className="text-[#637588] text-sm font-normal leading-normal">
                報告されたすべての農業災害イベントを閲覧・管理できます。各項目には、
                発生日、被災地域、被害の概要に関する詳細情報が記載されています。
              </p>
            </div>
          </div>

          <div className="px-4 py-3 @container">
            {/* ローディング状態 */}
            {isLoading && (
              <div className="p-8">
                <LoadingSpinner message="災害情報を読み込み中..." className="mb-4" />
                <LoadingTable rows={10} columns={5} />
              </div>
            )}

            {/* エラー状態 */}
            {isError && apiError && (
              <ErrorDisplay
                title="災害情報の取得に失敗しました"
                message={apiError.message}
                onRetry={() => refetch()}
                className="mb-4"
              />
            )}

            {/* データ表示 */}
            {!isLoading && !isError && (
              <>
                {disasters.length === 0 ? (
                  <EmptyState
                    title="災害情報が見つかりませんでした"
                    description="現在登録されている災害情報がありません。"
                    icon={<FileX className="h-12 w-12 text-gray-400" />}
                  />
                ) : (
                  <div className="flex overflow-hidden rounded-lg border border-[#dce0e5] bg-white">
                    <table className="flex-1">
                      <thead>
                        <tr className="bg-white">
                          <th className="table-column-120 px-4 py-3 text-left text-[#111418] w-[400px] text-sm font-medium leading-normal">
                            発生日
                          </th>
                          <th className="table-column-240 px-4 py-3 text-left text-[#111418] w-[400px] text-sm font-medium leading-normal">
                            災害名
                          </th>
                          <th className="table-column-360 px-4 py-3 text-left text-[#111418] w-[400px] text-sm font-medium leading-normal">
                            災害種別
                          </th>
                          <th className="table-column-480 px-4 py-3 text-left text-[#111418] w-60 text-sm font-medium leading-normal">
                            ステータス
                          </th>
                          <th className="table-column-600 px-4 py-3 text-left text-[#111418] w-60 text-[#637588] text-sm font-medium leading-normal">
                            アクション
                          </th>
                        </tr>
                      </thead>
                      <tbody>
                        {disasters.map((disaster: HandlerListDisastersResponse) => (
                          <tr key={disaster.id} className="border-t border-t-[#dce0e5]">
                            <td className="table-column-120 h-[72px] px-4 py-2 w-[400px] text-[#637588] text-sm font-normal leading-normal">
                              {disaster.occurred_at ? formatDate(disaster.occurred_at) : '-'}
                            </td>
                            <td className="table-column-240 h-[72px] px-4 py-2 w-[400px] text-[#111418] text-sm font-normal leading-normal">
                              {disaster.name || '-'}
                            </td>
                            <td className="table-column-360 h-[72px] px-4 py-2 w-[400px] text-[#637588] text-sm font-normal leading-normal">
                              {disaster.disaster_type || '-'}
                            </td>
                            <td className="table-column-480 h-[72px] px-4 py-2 w-60 text-sm font-normal leading-normal">
                              <button className={`flex min-w-[84px] max-w-[480px] cursor-pointer items-center justify-center overflow-hidden rounded-lg h-8 px-4 ${getStatusBadgeClass(disaster.status || '')} text-sm font-medium leading-normal w-full`}>
                                <span className="truncate">{getStatusLabel(disaster.status || '')}</span>
                              </button>
                            </td>
                            <td className="table-column-600 h-[72px] px-4 py-2 w-60 text-sm font-bold leading-normal tracking-[0.015em]">
                              <Link
                                href={`/disasters/${disaster.id}`}
                                className="text-[#007bff] hover:underline"
                              >
                                詳細を表示
                              </Link>
                            </td>
                          </tr>
                        ))}
                      </tbody>
                    </table>
                  </div>
                )}
              </>
            )}
          </div>
        </div>
      </main>
      <Footer />
    </div>
  )
}
</file>

<file path="frontend/orval.config.js">
module.exports = {
  backend: {
    output: {
      mode: "split",
      target: "src/api/client.ts",
      schemas: "src/api/model",
      client: "react-query",
      mock: true,
      prettier: {
        semi: false,
        singleQuote: true,
        trailingComma: 'es5',
      },
    },
    input: {
      target: "../backend/docs/swagger.yaml", // OpenAPI仕様ファイル
    },
  },
}
</file>

<file path="docker-compose.yml">
services:
  gen-api:
    container_name: gen-api
    build:
      context: ./backend
      dockerfile: build/api/Dockerfile-dev
    command: air -c .air.toml
    ports:
      - "8080:8080"
      - "2345:2345"
    depends_on:
      - db
      - db-test
    env_file:
      - .env
    volumes:
      - ./backend:/go/src/
    networks:
      - gen-network
    restart: unless-stopped
  db:
    image: postgres:17-alpine
    container_name: db
    ports:
      - "5432:5432"
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=postgres
      - POSTGRES_DB=gen
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - gen-network
    restart: unless-stopped
  db-test:
    image: postgres:15-alpine
    container_name: db-test
    ports:
      - "15432:5432"
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=postgres
      - POSTGRES_DB=gen_test
    volumes:
      - postgres_test_data:/var/lib/postgresql/data
    networks:
      - gen-network
    restart: unless-stopped
  migration:
    container_name: migration
    image: migrate/migrate
    entrypoint: /bin/sh
    tty: true
    volumes:
      - ./backend/migrations:/migrations
    working_dir: /migrations
    depends_on:
      - db
      - db-test
    networks:
      - gen-network

networks:
  gen-network:
    driver: bridge

volumes:
  postgres_data:
  # 既存のボリュームを削除して新たに作成する場合は、以下のコマンドを実行：
  # docker-compose down -v
  # docker-compose up -d
  postgres_test_data:
</file>

<file path="backend/internal/domain/query/gen.go">
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"database/sql"

	"gorm.io/gorm"

	"gorm.io/gen"

	"gorm.io/plugin/dbresolver"
)

var (
	Q          = new(Query)
	Disaster   *disaster
	Prefecture *prefecture
	Region     *region
	User       *user
)

func SetDefault(db *gorm.DB, opts ...gen.DOOption) {
	*Q = *Use(db, opts...)
	Disaster = &Q.Disaster
	Prefecture = &Q.Prefecture
	Region = &Q.Region
	User = &Q.User
}

func Use(db *gorm.DB, opts ...gen.DOOption) *Query {
	return &Query{
		db:         db,
		Disaster:   newDisaster(db, opts...),
		Prefecture: newPrefecture(db, opts...),
		Region:     newRegion(db, opts...),
		User:       newUser(db, opts...),
	}
}

type Query struct {
	db *gorm.DB

	Disaster   disaster
	Prefecture prefecture
	Region     region
	User       user
}

func (q *Query) Available() bool { return q.db != nil }

func (q *Query) clone(db *gorm.DB) *Query {
	return &Query{
		db:         db,
		Disaster:   q.Disaster.clone(db),
		Prefecture: q.Prefecture.clone(db),
		Region:     q.Region.clone(db),
		User:       q.User.clone(db),
	}
}

func (q *Query) ReadDB() *Query {
	return q.ReplaceDB(q.db.Clauses(dbresolver.Read))
}

func (q *Query) WriteDB() *Query {
	return q.ReplaceDB(q.db.Clauses(dbresolver.Write))
}

func (q *Query) ReplaceDB(db *gorm.DB) *Query {
	return &Query{
		db:         db,
		Disaster:   q.Disaster.replaceDB(db),
		Prefecture: q.Prefecture.replaceDB(db),
		Region:     q.Region.replaceDB(db),
		User:       q.User.replaceDB(db),
	}
}

type queryCtx struct {
	Disaster   IDisasterDo
	Prefecture IPrefectureDo
	Region     IRegionDo
	User       IUserDo
}

func (q *Query) WithContext(ctx context.Context) *queryCtx {
	return &queryCtx{
		Disaster:   q.Disaster.WithContext(ctx),
		Prefecture: q.Prefecture.WithContext(ctx),
		Region:     q.Region.WithContext(ctx),
		User:       q.User.WithContext(ctx),
	}
}

func (q *Query) Transaction(fc func(tx *Query) error, opts ...*sql.TxOptions) error {
	return q.db.Transaction(func(tx *gorm.DB) error { return fc(q.clone(tx)) }, opts...)
}

func (q *Query) Begin(opts ...*sql.TxOptions) *QueryTx {
	tx := q.db.Begin(opts...)
	return &QueryTx{Query: q.clone(tx), Error: tx.Error}
}

type QueryTx struct {
	*Query
	Error error
}

func (q *QueryTx) Commit() error {
	return q.db.Commit().Error
}

func (q *QueryTx) Rollback() error {
	return q.db.Rollback().Error
}

func (q *QueryTx) SavePoint(name string) error {
	return q.db.SavePoint(name).Error
}

func (q *QueryTx) RollbackTo(name string) error {
	return q.db.RollbackTo(name).Error
}
</file>

<file path="backend/migrations/000001_create_users_table.up.sql">
DROP TABLE IF EXISTS users;
CREATE TABLE IF NOT EXISTS users
(
    id         SERIAL PRIMARY KEY,
    name       VARCHAR(255) NOT NULL,
    email      VARCHAR(255) NOT NULL UNIQUE,
    password   VARCHAR(255) NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP WITH TIME ZONE
);

CREATE INDEX IF NOT EXISTS idx_users_email ON users (email);
CREATE INDEX IF NOT EXISTS idx_users_deleted_at ON users (deleted_at);
</file>

<file path="frontend/src/app/layout.tsx">
import type { Metadata } from "next"
import { Geist, Geist_Mono } from "next/font/google"
import { Providers } from "@/lib/providers"
import "./globals.css"

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
})

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
})

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
}

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        <Providers>{children}</Providers>
      </body>
    </html>
  )
}
</file>

<file path="frontend/src/components/layout/header/page.tsx">
import Link from "next/link"

const Header = () => {
  return (
    <header className="flex items-center justify-between whitespace-nowrap border-b border-solid border-b-[#f0f2f4] px-10 py-3">
      <div className="flex items-center gap-4 text-[#111418]">
        <div className="size-4">
          <svg
            viewBox="0 0 48 48"
            fill="none"
            xmlns="http://www.w3.org/2000/svg"
          >
            <path
              fillRule="evenodd"
              clipRule="evenodd"
              d="M24 4H42V17.3333V30.6667H24V44H6V30.6667V17.3333H24V4Z"
              fill="currentColor"
            ></path>
          </svg>
        </div>
        <h2 className="text-[#111418] text-lg font-bold leading-tight tracking-[-0.015em]">
          AgriSupport
        </h2>
      </div>
      <div className="flex flex-1 justify-end gap-8">
        <div className="flex items-center gap-9">
          <Link
            className="text-[#111418] text-sm font-medium leading-normal"
            href="/"
          >
            ホーム
          </Link>
          <Link
            className="text-[#111418] text-sm font-medium leading-normal"
            href="/disasters"
          >
            災害情報
          </Link>
          <Link
            className="text-[#111418] text-sm font-medium leading-normal"
            href="/application"
          >
            申請
          </Link>
          <Link
            className="text-[#111418] text-sm font-medium leading-normal"
            href="/application"
          >
            評価
          </Link>
        </div>
        <button className="flex max-w-[480px] cursor-pointer items-center justify-center overflow-hidden rounded-lg h-10 bg-[#f0f2f4] text-[#111418] gap-2 text-sm font-bold leading-normal tracking-[0.015em] min-w-0 px-2.5">
          <div className="text-[#111418]">
            <svg
              xmlns="http://www.w3.org/2000/svg"
              width="20px"
              height="20px"
              fill="currentColor"
              viewBox="0 0 256 256"
            >
              <path d="M221.8,175.94C216.25,166.38,208,139.33,208,104a80,80,0,1,0-160,0c0,35.34-8.26,62.38-13.81,71.94A16,16,0,0,0,48,200H88.81a40,40,0,0,0,78.38,0H208a16,16,0,0,0,13.8-24.06ZM128,216a24,24,0,0,1-22.62-16h45.24A24,24,0,0,1,128,216ZM48,184c7.7-13.24,16-43.92,16-80a64,64,0,1,1,128,0c0,36.05,8.28,66.73,16,80Z"></path>
            </svg>
          </div>
        </button>
        <div
          className="bg-center bg-no-repeat aspect-square bg-cover rounded-full size-10"
          style={{
            backgroundImage:
              'url("https://lh3.googleusercontent.com/aida-public/AB6AXuCm5IN8QKkL-lJx0Q9_mG2_4r9vIEtptFifAGkNomjcCGwiEftXFxA_n05l6T8XjBGLHSk8PtOM83D9DnfJ-R9OLKjOsOyU5fRCf_Ef5_vPhHitQuj5Q0yubOWYjv1yhQ3vNi051H63y2nsOojqs93D_uHp9zXAyHeiD68KhIUyqtqISYc5w0IAOjrlT8NxHHYSrWVA5mDvEnDfLtYqcZCknU662Ur2WUub3LUsYg47yLnrPfzTY5HqeN3e2skAaKdnGKHsLhOcy70")',
          }}
        ></div>
      </div>
    </header>
  )
}

export default Header
</file>

<file path="backend/cmd/api/main.go">
package main

import (
	"context"
	"net/http"

	"github.com/gin-gonic/gin"
	"go.uber.org/fx"

	"github.com/AI1411/fullstack-react-go/internal/handler"
	"github.com/AI1411/fullstack-react-go/internal/infra/datastore"
	"github.com/AI1411/fullstack-react-go/internal/infra/db"
	"github.com/AI1411/fullstack-react-go/internal/infra/logger"
	"github.com/AI1411/fullstack-react-go/internal/middleware"
	"github.com/AI1411/fullstack-react-go/internal/usecase"
)

// Module groups provide a way to organize dependencies
type Module struct {
	fx.Out

	Logger          *logger.Logger
	DBClient        db.Client
	GinEngine       *gin.Engine
	DisasterRepo    datastore.DisasterRepository
	DisasterUsecase usecase.DisasterUseCase
	DisasterHandler handler.Disaster
}

// ProvideLogger creates a new logger instance
func ProvideLogger() *logger.Logger {
	return logger.New(logger.DefaultConfig())
}

// ProvideDBClient creates a new database client
func ProvideDBClient(lc fx.Lifecycle, l *logger.Logger) (db.Client, error) {
	dbClient, err := db.NewSqlHandler(db.DefaultDatabaseConfig(), l)
	if err != nil {
		l.Error("failed to connect to database", "error", err)
		return nil, err
	}

	// Register lifecycle hooks for the database client
	lc.Append(fx.Hook{
		OnStop: func(ctx context.Context) error {
			l.Info("Closing database connection")
			return nil // Add proper cleanup if needed
		},
	})

	return dbClient, nil
}

// ProvideGinEngine creates and configures a new Gin engine
func ProvideGinEngine(l *logger.Logger) *gin.Engine {
	r := gin.Default()

	// ミドルウェアの設定
	r.Use(gin.Logger())
	r.Use(gin.Recovery())
	r.Use(middleware.NewLogging(l))
	r.Use(middleware.CORSMiddleware())

	return r
}

// ProvideDisasterRepository creates a new disaster repository
func ProvideDisasterRepository(dbClient db.Client) datastore.DisasterRepository {
	ctx := context.Background()
	return datastore.NewDisasterRepository(ctx, dbClient)
}

// ProvideDisasterUseCase creates a new disaster use case
func ProvideDisasterUseCase(repo datastore.DisasterRepository) usecase.DisasterUseCase {
	return usecase.NewDisasterUseCase(repo)
}

// ProvideDisasterHandler creates a new disaster handler
func ProvideDisasterHandler(usecase usecase.DisasterUseCase) handler.Disaster {
	return handler.NewDisasterHandler(usecase)
}

// RegisterRoutes registers all HTTP routes
func RegisterRoutes(
	lc fx.Lifecycle,
	r *gin.Engine,
	l *logger.Logger,
	dbClient db.Client,
	disasterHandler handler.Disaster,
) {
	// Context for health check
	ctx := context.Background()

	// ヘルスチェックエンドポイント
	r.GET("/health", func(c *gin.Context) {
		if err := dbClient.Ping(ctx); err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{
				"status": "unhealthy",
				"error":  "database ping failed",
			})

			return
		}

		c.JSON(http.StatusOK, gin.H{
			"status":   "healthy",
			"database": "connected",
		})
	})

	r.GET("/disasters", disasterHandler.ListDisasters)

	// Swagger JSON エンドポイント
	r.GET("/docs", func(c *gin.Context) {
		c.Header("Content-Type", "application/json")
		c.File("./docs/swagger.json")
	})

	// Register lifecycle hooks for the HTTP server
	lc.Append(fx.Hook{
		OnStart: func(ctx context.Context) error {
			// Start HTTP server in a goroutine so it doesn't block
			go func() {
				l.Info("Starting server on :8080")
				if err := r.Run(":8080"); err != nil {
					l.Error("Failed to start server", "error", err)
				}
			}()
			return nil
		},
		OnStop: func(ctx context.Context) error {
			l.Info("Shutting down server")
			return nil // Add proper cleanup if needed
		},
	})
}

func main() {
	app := fx.New(
		// Provide all the constructors needed by the application
		fx.Provide(
			ProvideLogger,
			ProvideDBClient,
			ProvideGinEngine,
			ProvideDisasterRepository,
			ProvideDisasterUseCase,
			ProvideDisasterHandler,
		),
		// Register the lifecycle hooks
		fx.Invoke(RegisterRoutes),
	)

	// Run the application
	app.Run()
}
</file>

<file path="backend/migrations/000003_create_disasters_table.up.sql">
-- 既存のENUM型を削除して再作成
DROP TYPE IF EXISTS disaster_status CASCADE;
CREATE TYPE disaster_status AS ENUM ('pending', 'under_review', 'in_progress', 'completed');

-- 既存テーブルを削除して再作成
DROP TABLE IF EXISTS disasters CASCADE;
CREATE TABLE IF NOT EXISTS disasters
(
    id                      UUID PRIMARY KEY                  DEFAULT gen_random_uuid(),
    disaster_code           VARCHAR(20)              NOT NULL UNIQUE,
    name                    VARCHAR(100)             NOT NULL,
    prefecture_id           INT                      NOT NULL REFERENCES prefectures (id),
    occurred_at             TIMESTAMP WITH TIME ZONE NOT NULL,
    summary                 TEXT                     NOT NULL,
    disaster_type           VARCHAR(30)              NOT NULL,
    status                  disaster_status          NOT NULL DEFAULT 'pending',
    impact_level            VARCHAR(20)              NOT NULL,
    affected_area_size      DECIMAL(10, 2),
    estimated_damage_amount DECIMAL(15, 2),
    created_at              TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at              TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    deleted_at              TIMESTAMP WITH TIME ZONE
);

CREATE INDEX idx_disasters_prefecture_id ON disasters (prefecture_id);
CREATE INDEX idx_disasters_disaster_type ON disasters (disaster_type);
CREATE INDEX idx_disasters_status ON disasters (status);
CREATE INDEX idx_disasters_occurred_at ON disasters (occurred_at);

-- テーブルとカラムにコメントを追加
COMMENT ON TABLE disasters IS '農業災害情報管理テーブル - 各種災害の詳細情報を格納';
COMMENT ON COLUMN disasters.id IS '災害ID - 主キー';
COMMENT ON COLUMN disasters.disaster_code IS '災害コード - 管理用の一意識別子 (例: D2024-001)';
COMMENT ON COLUMN disasters.name IS '災害名 - 災害の名称';
COMMENT ON COLUMN disasters.prefecture_id IS '都道府県ID - 災害が発生した都道府県のID';
COMMENT ON COLUMN disasters.occurred_at IS '発生日時 - 災害が発生した日時';
COMMENT ON COLUMN disasters.summary IS '被害概要 - 災害による被害の詳細説明';
COMMENT ON COLUMN disasters.disaster_type IS '災害種別 - 洪水, 地滑り, 雹害, 干ばつ, 風害, 地震, 霜害, 病害虫など';
COMMENT ON COLUMN disasters.status IS '状態 - pending(未着手), under_review(審査中), in_progress(対応中), completed(完了)のいずれか';
COMMENT ON COLUMN disasters.impact_level IS '被害レベル - 軽微, 中程度, 深刻, 甚大などの被害度合い';
COMMENT ON COLUMN disasters.affected_area_size IS '被害面積 - ヘクタール (ha) 単位での被害エリアの広さ';
COMMENT ON COLUMN disasters.estimated_damage_amount IS '被害推定金額 - 円単位での被害総額';
COMMENT ON COLUMN disasters.created_at IS '作成日時 - レコード作成日時';
COMMENT ON COLUMN disasters.updated_at IS '更新日時 - レコード最終更新日時';
COMMENT ON COLUMN disasters.deleted_at IS '削除日時 - 論理削除用のタイムスタンプ';

-- 農業災害テストデータの挿入
-- 前提: prefecturesテーブルに都道府県データが存在することを想定

INSERT INTO disasters (disaster_code,
                       name,
                       prefecture_id,
                       occurred_at,
                       summary,
                       disaster_type,
                       status,
                       impact_level,
                       affected_area_size,
                       estimated_damage_amount,
                       created_at,
                       updated_at)
VALUES
-- 2024年の災害データ
('D2024-001',
 '令和6年7月豪雨による水稲被害',
 13, -- 東京都
 '2024-07-10 14:30:00+09',
 '集中豪雨により水田が冠水し、出穂期の水稲に甚大な被害が発生。約200ヘクタールの水田で倒伏・流失が確認された。',
 '洪水',
 'completed',
 '甚大',
 200.50,
 150000000.00,
 '2024-07-11 09:00:00+09',
 '2024-08-15 16:30:00+09'),
('D2024-002',
 '春季霜害によるりんご園被害',
 2, -- 青森県
 '2024-04-18 03:45:00+09',
 '開花期の異常低温により、県内主要産地のりんご園で花芽・幼果に霜害が発生。収穫量の大幅な減少が予想される。',
 '霜害',
 'in_progress',
 '深刻',
 350.75,
 280000000.00,
 '2024-04-18 08:00:00+09',
 '2024-05-20 14:20:00+09'),
('D2024-003',
 '梅雨期長雨による野菜価格高騰',
 14, -- 神奈川県
 '2024-06-15 00:00:00+09',
 '梅雨前線の停滞により長期間の降雨が続き、露地野菜の生育不良と病害が多発。特にキャベツ、レタスの出荷量が大幅減少。',
 '長雨',
 'under_review',
 '中程度',
 120.30,
 45000000.00,
 '2024-06-20 10:15:00+09',
 '2024-06-25 11:45:00+09'),
('D2024-004',
 'ひょう害によるぶどう栽培被害',
 19, -- 山梨県
 '2024-05-28 16:20:00+09',
 '局地的な雹の襲来により、ぶどう栽培地域で葉や幼果に物理的損傷が発生。特に甲州種の被害が深刻。',
 '雹害',
 'in_progress',
 '深刻',
 85.20,
 120000000.00,
 '2024-05-28 18:30:00+09',
 '2024-06-10 09:20:00+09'),
('D2024-005',
 '台風15号による農業施設損壊',
 12, -- 千葉県
 '2024-09-08 22:15:00+09',
 '台風15号の強風によりビニールハウスや農業倉庫が損壊。施設園芸作物への直接被害も確認されている。',
 '風害',
 'pending',
 '甚大',
 45.80,
 200000000.00,
 '2024-09-09 07:00:00+09',
 '2024-09-09 07:00:00+09'),
-- 2023年の災害データ
('D2023-078',
 '夏季干ばつによる畑作物被害',
 1, -- 北海道
 '2023-08-05 12:00:00+09',
 '記録的な少雨により土壌水分が不足し、じゃがいも、とうもろこし等の畑作物に深刻な生育障害が発生。',
 '干ばつ',
 'completed',
 '深刻',
 1250.00,
 350000000.00,
 '2023-08-10 14:30:00+09',
 '2023-10-31 17:00:00+09'),
('D2023-089',
 'いもち病大発生による稲作被害',
 15, -- 新潟県
 '2023-07-22 00:00:00+09',
 '高温多湿な気象条件下でいもち病が大発生し、県内の水稲作付面積の約15%に被害が拡大。',
 '病害虫',
 'completed',
 '中程度',
 450.25,
 95000000.00,
 '2023-07-25 08:45:00+09',
 '2023-09-15 16:20:00+09'),
('D2023-091',
 '地滑りによる棚田被害',
 17, -- 石川県
 '2023-06-30 04:20:00+09',
 '豪雨による地盤の緩みで山間部の棚田において地滑りが発生。貴重な文化的景観と農地が失われた。',
 '地滑り',
 'completed',
 '深刻',
 12.50,
 25000000.00,
 '2023-06-30 09:00:00+09',
 '2023-08-20 15:30:00+09'),
('D2023-045',
 '春季低温による茶葉品質低下',
 22, -- 静岡県
 '2023-04-12 06:00:00+09',
 '新茶の摘採期に異常低温が継続し、茶葉の生育遅延と品質低下が発生。一番茶の収量・品質ともに例年を大きく下回る。',
 '低温',
 'completed',
 '中程度',
 180.40,
 80000000.00,
 '2023-04-15 11:20:00+09',
 '2023-06-10 14:50:00+09'),
-- 軽微な被害の例
('D2024-006',
 '局地的豪雨による小規模冠水',
 11, -- 埼玉県
 '2024-08-20 15:45:00+09',
 '短時間の集中豪雨により一部農地で冠水が発生したが、排水対応により被害は最小限に抑制された。',
 '洪水',
 'completed',
 '軽微',
 8.30,
 2500000.00,
 '2024-08-20 18:00:00+09',
 '2024-08-22 10:30:00+09'),
('D2024-007',
 'コナガ発生による白菜軽微被害',
 27, -- 大阪府
 '2024-10-05 00:00:00+09',
 '秋冬野菜の生育期にコナガの発生が確認されたが、早期防除により被害は軽微に留まった。',
 '病害虫',
 'in_progress',
 '軽微',
 25.60,
 8000000.00,
 '2024-10-08 09:30:00+09',
 '2024-10-15 14:20:00+09'),
-- 審査中・未着手の災害
('D2024-008',
 '秋季台風による果樹園被害報告',
 34, -- 広島県
 '2024-10-12 08:30:00+09',
 '台風による強風で柿、みかん等の果樹に落果被害が発生した可能性があり、現在被害状況を調査中。',
 '風害',
 'under_review',
 '中程度',
 95.20,
 NULL, -- 査定中のため金額未確定
 '2024-10-15 10:00:00+09',
 '2024-10-20 16:45:00+09'),
('D2024-009',
 '病害虫発生報告（詳細調査待ち）',
 46, -- 鹿児島県
 '2024-11-01 00:00:00+09',
 'さつまいも栽培地域で新たな病害の発生が疑われており、専門機関による詳細な調査が必要な状況。',
 '病害虫',
 'pending',
 '不明',
 NULL, -- 調査前のため面積未確定
 NULL, -- 調査前のため金額未確定
 '2024-11-05 13:20:00+09',
 '2024-11-05 13:20:00+09');
</file>

<file path="backend/go.mod">
module github.com/AI1411/fullstack-react-go

go 1.24

require (
	github.com/gin-contrib/cors v1.7.5
	github.com/gin-gonic/gin v1.10.1
	github.com/google/uuid v1.6.0
	github.com/kelseyhightower/envconfig v1.4.0
	github.com/pkg/errors v0.9.1
	github.com/swaggo/swag v1.16.4
	go.uber.org/fx v1.21.0
	gorm.io/driver/postgres v1.5.11
	gorm.io/gen v0.3.27
	gorm.io/gorm v1.30.0
	gorm.io/plugin/dbresolver v1.6.0
)

require (
	filippo.io/edwards25519 v1.1.0 // indirect
	github.com/KyleBanks/depth v1.2.1 // indirect
	github.com/PuerkitoBio/purell v1.1.1 // indirect
	github.com/PuerkitoBio/urlesc v0.0.0-20170810143723-de5bf2ad4578 // indirect
	github.com/bytedance/sonic v1.13.2 // indirect
	github.com/bytedance/sonic/loader v0.2.4 // indirect
	github.com/cloudwego/base64x v0.1.5 // indirect
	github.com/gabriel-vasile/mimetype v1.4.8 // indirect
	github.com/gin-contrib/sse v1.0.0 // indirect
	github.com/go-openapi/jsonpointer v0.19.5 // indirect
	github.com/go-openapi/jsonreference v0.19.6 // indirect
	github.com/go-openapi/spec v0.20.4 // indirect
	github.com/go-openapi/swag v0.19.15 // indirect
	github.com/go-playground/locales v0.14.1 // indirect
	github.com/go-playground/universal-translator v0.18.1 // indirect
	github.com/go-playground/validator/v10 v10.26.0 // indirect
	github.com/go-sql-driver/mysql v1.8.1 // indirect
	github.com/goccy/go-json v0.10.5 // indirect
	github.com/jackc/pgpassfile v1.0.0 // indirect
	github.com/jackc/pgservicefile v0.0.0-20231201235250-de7065d80cb9 // indirect
	github.com/jackc/pgx/v5 v5.5.5 // indirect
	github.com/jackc/puddle/v2 v2.2.1 // indirect
	github.com/jinzhu/inflection v1.0.0 // indirect
	github.com/jinzhu/now v1.1.5 // indirect
	github.com/josharian/intern v1.0.0 // indirect
	github.com/json-iterator/go v1.1.12 // indirect
	github.com/klauspost/cpuid/v2 v2.2.10 // indirect
	github.com/leodido/go-urn v1.4.0 // indirect
	github.com/mailru/easyjson v0.7.6 // indirect
	github.com/mattn/go-isatty v0.0.20 // indirect
	github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd // indirect
	github.com/modern-go/reflect2 v1.0.2 // indirect
	github.com/pelletier/go-toml/v2 v2.2.3 // indirect
	github.com/rogpeppe/go-internal v1.14.1 // indirect
	github.com/twitchyliquid64/golang-asm v0.15.1 // indirect
	github.com/ugorji/go/codec v1.2.12 // indirect
	go.uber.org/dig v1.17.1 // indirect
	go.uber.org/multierr v1.10.0 // indirect
	go.uber.org/zap v1.26.0 // indirect
	golang.org/x/arch v0.15.0 // indirect
	golang.org/x/crypto v0.36.0 // indirect
	golang.org/x/mod v0.22.0 // indirect
	golang.org/x/net v0.38.0 // indirect
	golang.org/x/sync v0.12.0 // indirect
	golang.org/x/sys v0.31.0 // indirect
	golang.org/x/text v0.23.0 // indirect
	google.golang.org/protobuf v1.36.6 // indirect
	gopkg.in/yaml.v2 v2.4.0 // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
	gorm.io/datatypes v1.2.5 // indirect
	gorm.io/driver/mysql v1.5.7 // indirect
	gorm.io/hints v1.1.0 // indirect
)
</file>

<file path="frontend/src/app/page.tsx">
"use client"

import Header from "@/components/layout/header/page"
import { useListDisasters } from "@/api/client"
import Link from "next/link"

export default function Home() {
  // 災害情報を取得
  const {
    data: disastersResponse,
    isLoading,
    isError
  } = useListDisasters({
    query: {
      staleTime: 5 * 60 * 1000, // 5分間キャッシュ
    }
  })

  const disasters = disastersResponse?.data || []

  // 統計情報を計算
  const totalDisasters = disasters.length
  const pendingCount = disasters.filter(d => d.status === 'pending' || d.status === 'under_review').length
  const recentDisasters = disasters
    .sort((a, b) => new Date(b.occurred_at || '').getTime() - new Date(a.occurred_at || '').getTime())
    .slice(0, 5)

  // 日付フォーマット関数
  const formatDate = (dateString: string) => {
    const date = new Date(dateString)
    return date.toLocaleDateString('ja-JP', {
      year: 'numeric',
      month: '2-digit',
      day: '2-digit'
    })
  }

  // ステータスの日本語表示
  const getStatusLabel = (status: string) => {
    switch (status) {
      case "pending":
        return "未着手"
      case "under_review":
        return "審査中"
      case "in_progress":
        return "対応中"
      case "completed":
        return "完了"
      default:
        return status
    }
  }

  return (
    <div className="layout-container flex h-full grow flex-col">
      <Header />
      <main className="px-40 flex flex-1 justify-center py-5">
        <div className="layout-content-container flex flex-col max-w-[960px] flex-1">
          <div className="flex flex-wrap justify-between gap-3 p-4">
            <div className="flex min-w-72 flex-col gap-3">
              <p className="text-[#111418] tracking-light text-[32px] font-bold leading-tight">
                ダッシュボード
              </p>
              <p className="text-[#637588] text-sm font-normal leading-normal">
                お疲れさまです！システムの概要と最新の災害情報をご確認ください。
              </p>
            </div>
          </div>

          <h2 className="text-[#111418] text-[22px] font-bold leading-tight tracking-[-0.015em] px-4 pb-3 pt-5">
            システム概要
          </h2>
          <div className="flex flex-wrap gap-4 p-4">
            <div className="flex min-w-[158px] flex-1 flex-col gap-2 rounded-lg p-6 border border-[#dce0e5]">
              <p className="text-[#111418] text-base font-medium leading-normal">
                総災害件数
              </p>
              {isLoading ? (
                <div className="animate-pulse bg-gray-200 h-8 rounded"></div>
              ) : (
                <p className="text-[#111418] tracking-light text-2xl font-bold leading-tight">
                  {totalDisasters.toLocaleString()}
                </p>
              )}
            </div>
            <div className="flex min-w-[158px] flex-1 flex-col gap-2 rounded-lg p-6 border border-[#dce0e5]">
              <p className="text-[#111418] text-base font-medium leading-normal">
                対応待ち
              </p>
              {isLoading ? (
                <div className="animate-pulse bg-gray-200 h-8 rounded"></div>
              ) : (
                <p className="text-[#111418] tracking-light text-2xl font-bold leading-tight">
                  {pendingCount.toLocaleString()}
                </p>
              )}
            </div>
            <div className="flex min-w-[158px] flex-1 flex-col gap-2 rounded-lg p-6 border border-[#dce0e5]">
              <p className="text-[#111418] text-base font-medium leading-normal">
                完了済み
              </p>
              {isLoading ? (
                <div className="animate-pulse bg-gray-200 h-8 rounded"></div>
              ) : (
                <p className="text-[#111418] tracking-light text-2xl font-bold leading-tight">
                  {disasters.filter(d => d.status === 'completed').length.toLocaleString()}
                </p>
              )}
            </div>
          </div>

          <h2 className="text-[#111418] text-[22px] font-bold leading-tight tracking-[-0.015em] px-4 pb-3 pt-5">
            最新災害情報
          </h2>
          
          {isLoading ? (
            <div className="p-4">
              <div className="animate-pulse">
                <div className="bg-gray-200 h-6 rounded mb-2"></div>
                <div className="bg-gray-200 h-4 rounded mb-4"></div>
                <div className="bg-gray-200 h-32 rounded"></div>
              </div>
            </div>
          ) : isError ? (
            <div className="p-4">
              <div className="bg-red-50 border border-red-200 rounded-lg p-4">
                <p className="text-red-600">災害情報の取得に失敗しました</p>
              </div>
            </div>
          ) : recentDisasters.length > 0 ? (
            <div className="p-4">
              <div className="flex items-stretch justify-between gap-4 rounded-lg">
                <div className="flex flex-col gap-1 flex-[2_2_0px]">
                  <p className="text-[#111418] text-base font-bold leading-tight">
                    {recentDisasters[0].name}
                  </p>
                  <p className="text-[#637588] text-sm font-normal leading-normal">
                    {recentDisasters[0].summary}
                  </p>
                  <p className="text-[#637588] text-xs font-normal leading-normal mt-2">
                    発生日: {recentDisasters[0].occurred_at ? formatDate(recentDisasters[0].occurred_at) : '-'} | 
                    状態: {getStatusLabel(recentDisasters[0].status || '')}
                  </p>
                </div>
                <div
                  className="w-full bg-center bg-no-repeat aspect-video bg-cover rounded-lg flex-1"
                  style={{
                    backgroundImage:
                      'url("https://lh3.googleusercontent.com/aida-public/AB6AXuAwL6_AdRbGqk3fz9oAyKgApsJ5lzCZr323vDQidQ9sUfYW8fL05o-F1utFzuhac0AdevlWakVlW9vzMCRB7o_50MQ7boxvgVAkfcpYppzmOj0ApvLQc-dIfIhILwFZEzbaAXyFtfO4opsZF3lJTppgRsbw5Bs-DkYdzhVUAOh0Azxj54F00OhUq-XNDvnuNK5PCypb7MbFNqq1njXjjA8Mze_JUSLaovZSz4hDcO_wGxaoLBjVYxHtVpnfSQdmZDYXQmn10XKZ7kY")',
                  }}
                ></div>
              </div>
            </div>
          ) : (
            <div className="p-4">
              <p className="text-[#637588] text-center">災害情報がありません</p>
            </div>
          )}

          <h2 className="text-[#111418] text-[22px] font-bold leading-tight tracking-[-0.015em] px-4 pb-3 pt-5">
            最近の災害一覧
          </h2>
          <div className="px-4 py-3 @container">
            {isLoading ? (
              <div className="animate-pulse">
                <div className="bg-gray-200 h-12 rounded mb-2"></div>
                <div className="space-y-2">
                  {[...Array(5)].map((_, i) => (
                    <div key={i} className="bg-gray-200 h-16 rounded"></div>
                  ))}
                </div>
              </div>
            ) : isError ? (
              <div className="bg-red-50 border border-red-200 rounded-lg p-4">
                <p className="text-red-600">災害一覧の取得に失敗しました</p>
              </div>
            ) : recentDisasters.length > 0 ? (
              <div className="flex overflow-hidden rounded-lg border border-[#dce0e5] bg-white">
                <table className="flex-1">
                  <thead>
                    <tr className="bg-white">
                      <th className="table-column-120 px-4 py-3 text-left text-[#111418] w-[400px] text-sm font-medium leading-normal">
                        災害コード
                      </th>
                      <th className="table-column-240 px-4 py-3 text-left text-[#111418] w-[400px] text-sm font-medium leading-normal">
                        災害名
                      </th>
                      <th className="table-column-360 px-4 py-3 text-left text-[#111418] w-60 text-sm font-medium leading-normal">
                        災害種別
                      </th>
                      <th className="table-column-480 px-4 py-3 text-left text-[#111418] w-60 text-sm font-medium leading-normal">
                        ステータス
                      </th>
                      <th className="table-column-600 px-4 py-3 text-left text-[#111418] w-[400px] text-sm font-medium leading-normal">
                        発生日
                      </th>
                    </tr>
                  </thead>
                  <tbody>
                    {recentDisasters.map((disaster) => (
                      <tr key={disaster.id} className="border-t border-t-[#dce0e5]">
                        <td className="table-column-120 h-[72px] px-4 py-2 w-[400px] text-[#111418] text-sm font-normal leading-normal">
                          <Link
                            href={`/disasters/${disaster.id}`}
                            className="text-[#007bff] hover:underline"
                          >
                            {disaster.disaster_code}
                          </Link>
                        </td>
                        <td className="table-column-240 h-[72px] px-4 py-2 w-[400px] text-[#637588] text-sm font-normal leading-normal">
                          {disaster.name}
                        </td>
                        <td className="table-column-360 h-[72px] px-4 py-2 w-60 text-sm font-normal leading-normal">
                          <button className="flex min-w-[84px] max-w-[480px] cursor-pointer items-center justify-center overflow-hidden rounded-lg h-8 px-4 bg-[#f0f2f4] text-[#111418] text-sm font-medium leading-normal w-full">
                            <span className="truncate">{disaster.disaster_type}</span>
                          </button>
                        </td>
                        <td className="table-column-480 h-[72px] px-4 py-2 w-60 text-sm font-normal leading-normal">
                          <button className="flex min-w-[84px] max-w-[480px] cursor-pointer items-center justify-center overflow-hidden rounded-lg h-8 px-4 bg-[#f0f2f4] text-[#111418] text-sm font-medium leading-normal w-full">
                            <span className="truncate">{getStatusLabel(disaster.status || '')}</span>
                          </button>
                        </td>
                        <td className="table-column-600 h-[72px] px-4 py-2 w-[400px] text-[#637588] text-sm font-normal leading-normal">
                          {disaster.occurred_at ? formatDate(disaster.occurred_at) : '-'}
                        </td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            ) : (
              <div className="text-center p-8">
                <p className="text-[#637588] text-lg">災害情報がありません</p>
              </div>
            )}
          </div>

          {/* 全件表示リンク */}
          <div className="p-4 text-center">
            <Link
              href="/disasters"
              className="inline-flex items-center justify-center px-6 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-[#111418] hover:bg-[#333] transition-colors"
            >
              すべての災害情報を見る
            </Link>
          </div>
        </div>
      </main>
    </div>
  )
}
</file>

<file path="frontend/package.json">
{
  "name": "frontend",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build",
    "start": "next start",
    "lint": "pnpm biome format --write ./src",
    "generate": "orval"
  },
  "dependencies": {
    "@radix-ui/react-slot": "^1.2.3",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "lucide-react": "^0.511.0",
    "msw": "^2.8.5",
    "next": "15.3.2",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "tailwind-merge": "^3.3.0",
    "zustand": "^4.5.2"
  },
  "devDependencies": {
    "@biomejs/biome": "1.9.4",
    "@tailwindcss/postcss": "^4",
    "@tanstack/react-query": "^5.28.4",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "axios": "^1.9.0",
    "orval": "^7.9.0",
    "tailwindcss": "^4",
    "tw-animate-css": "^1.3.0",
    "typescript": "^5"
  }
}
</file>

<file path="Makefile">
# PostgreSQL connection settings
DB_HOST ?= db
DB_PORT ?= 5432
DB_USER ?= postgres
DB_PASSWORD ?= postgres
DB_NAME ?= gen
DB_SSLMODE ?= disable
# PostgreSQL connection settings for test database
DB_TEST_HOST ?= db-test
DB_TEST_PORT ?= 5432
DB_TEST_USER ?= postgres
DB_TEST_PASSWORD ?= postgres
DB_TEST_NAME ?= gen_test
DB_TEST_SSLMODE ?= disable

# Construct database URL
DATABASE_URL = postgres://$(DB_USER):$(DB_PASSWORD)@$(DB_HOST):$(DB_PORT)/$(DB_NAME)?sslmode=$(DB_SSLMODE)
DATABASE_TEST_URL = postgres://$(DB_TEST_USER):$(DB_TEST_PASSWORD)@$(DB_TEST_HOST):$(DB_TEST_PORT)/$(DB_TEST_NAME)?sslmode=$(DB_TEST_SSLMODE)

.PHONY: migrate migrate-up migrate-down migrate-version migrate-create

# Run migration up
migrate:
	docker compose exec migration migrate -source file://./ -database '$(DATABASE_URL)' up
	docker compose exec migration migrate -source file://./ -database '$(DATABASE_TEST_URL)' up

# Alias for migrate
migrate-up: migrate

# Run migration down
migrate-down:
	docker compose exec migration migrate -source file://./ -database '$(DATABASE_URL)' down 1
	docker compose exec migration migrate -source file://./ -database '$(DATABASE_TEST_URL)' down 1

# Show current migration version
migrate-version:
	docker compose exec migration migrate -source file://./ -database '$(DATABASE_URL)' version
	docker compose exec migration migrate -source file://./ -database '$(DATABASE_TEST_URL)' version

# Create new migration file
migrate-create:
	@read -p "Enter migration name: " name; \
	docker compose exec migration migrate create -ext sql -dir ./ -seq $$name

.PHONY: logs
logs:
	docker logs gen-api -f --tail 100

.PHONY: generate-models
generate-models:
	@cd backend && rm -rf ./internal/domain/query/*.gen.go ./internal/domain/model/*.gen.go
	@cd backend && go run ./cmd/gormgen/generate_all/main.go

.PHONY: exec-schema
exec-schema: ## sqlファイルをコンテナに流す
	cat ./backend/migrations/*.up.sql > ./backend/migrations/schema.sql
	docker cp backend/migrations/schema.sql db:/schema.sql
	docker cp backend/migrations/schema.sql db-test:/schema.sql
	docker exec -it db psql -U postgres -d gen -f /schema.sql
	docker exec -it db-test psql -U postgres -d gen_test -f /schema.sql
	rm ./backend/migrations/schema.sql

.PHONY: swag
swag: ## swagger更新
	@docker compose exec gen-api swag init -g ./cmd/api/main.go
	@cd frontend && pnpm generate
fmt: ## コードを自動整形（ツールチェイン使用）
	@cd backend && go run mvdan.cc/gofumpt@latest -l -w .
	@cd backend && go run golang.org/x/tools/cmd/goimports@latest -l -w -local "github.com/AI1411/fullstack-react-go" .
	@cd frontend && pnpm lint

.PHONY: lint lint-fix test test-coverage vet sec staticcheck tools
## 開発ツール関連

tools: ## 開発ツールをインストール（ツールチェイン使用）
	@cd backend && go mod download
	@cd backend && go mod tidy

lint: ## 静的解析実行（ツールチェイン使用）
	@cd backend && go run github.com/golangci/golangci-lint/cmd/golangci-lint@latest run ./...

lint-fix: ## 静的解析で修正可能な問題を自動修正（ツールチェイン使用）
	@cd backend && go run github.com/golangci/golangci-lint/cmd/golangci-lint@latest run --fix ./...

vet: ## go vetを実行
	@cd backend && go vet ./...

staticcheck: ## staticcheckを実行（ツールチェイン使用）
	@cd backend && go run honnef.co/go/tools/cmd/staticcheck@latest ./...

sec: ## セキュリティチェック実行（ツールチェイン使用）
	@cd backend && go run golang.org/x/vuln/cmd/govulncheck@latest ./...

test: ## テスト実行
	@cd backend && go test -v ./...

test-coverage: ## テストカバレッジ計測
	@cd backend && go test -coverprofile=coverage.out ./...
	@cd backend && go tool cover -html=coverage.out -o coverage.html
	@echo "カバレッジレポートが coverage.html に生成されました"

quality: lint vet staticcheck sec ## コード品質チェック（全ツール）

ci: fmt quality test ## CI環境で実行するチェック
</file>

</files>
